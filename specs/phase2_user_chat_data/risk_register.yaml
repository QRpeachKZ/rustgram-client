# Risk Register: Phase 2 - User & Chat Data
# Epic: rustgram-client-1gk
# Version: 1.0
# Date: 2026-01-21
# Status: Active

---

## Metadata

- **Epic:** rustgram-client-1gk
- **Phase:** Phase 2 - User & Chat Data
- **Created:** 2026-01-21
- **Last Updated:** 2026-01-21
- **Owner:** Analyst Agent

---

## Risk Categories

1. **UNRESOLVED_API** - API ambiguity or missing functionality
2. **DEADLOCK** - Potential for deadlock in concurrent code
3. **TYPE_SAFETY** - Type system violations or unsafe code
4. **PERFORMANCE** - Performance degradation or resource issues
5. **MEMORY_LEAK** - Memory leaks or unbounded growth

---

## Risks

### R1: TL Schema Constructor ID Mismatch

**ID:** R1  
**Type:** UNRESOLVED_API  
**Status:** OPEN  
**Impact:** HIGH  
**Likelihood:** MEDIUM

**Description:**
TL constructor IDs must match TDLib's binary format exactly. Any mismatch will cause protocol failures and silent data corruption. The `users.getFullUser` constructor ID has not been verified against telegram_api.tl.

**Affected Components:**
- `user_manager/src/tl.rs` - GetFullUserRequest
- `dialog_manager/src/tl_types.rs` - GetFullChatRequest, GetFullChannelRequest
- `photo_downloader/src/tl.rs` - InputPhotoFileLocation

**Mitigation Strategy:**
1. Verify all constructor IDs against `references/td/td/generate/scheme/telegram_api.tl`
2. Create golden test vectors from TDLib for each request/response
3. Add contract tests validating binary format
4. Pin TDLib commit hash in documentation

**Owner:** Developer  
**Due Date:** Phase 0.5 (TL Schema Verification)  
**Contingency:**
If mismatch discovered, pause implementation until constructor IDs are corrected. May require TDLib protocol dumps for validation.

---

### R2: Missing ChatFull Type Implementation

**ID:** R2  
**Type:** UNRESOLVED_API  
**Status:** OPEN  
**Impact:** HIGH  
**Likelihood:** HIGH

**Description:**
ChatFull type has 20+ optional fields per telegram_api.tl:132. The type is not yet implemented in the codebase. Missing fields will cause deserialization failures.

**Affected Components:**
- `dialog_manager/src/tl_types.rs` - ChatFull struct

**Required Fields (telegram_api.tl:132):**
```
chatFull#2633421b flags:# can_set_username:flags.7?true 
    has_scheduled:flags.8?true translations_disabled:flags.19?true 
    id:long about:string participants:ChatParticipants 
    chat_photo:flags.2?Photo notify_settings:PeerNotifySettings 
    exported_invite:flags.13?ExportedChatInvite 
    bot_info:flags.3?Vector<BotInfo> pinned_msg_id:flags.6?int 
    folder_id:flags.11?int call:flags.12?InputGroupCall 
    ttl_period:flags.14?int groupcall_default_join_as:flags.15?Peer 
    theme_emoticon:flags.16?string requests_pending:flags.17?int 
    recent_requesters:flags.17?Vector<long> 
    available_reactions:flags.18?ChatReactions reactions_limit:flags.20?int 
    = ChatFull;
```

**Mitigation Strategy:**
1. Implement ChatFull struct with all 20+ fields
2. Use `Option<T>` for all optional fields
3. Implement TlDeserialize trait carefully for flag-based fields
4. Add comprehensive tests for deserialization

**Owner:** Developer  
**Due Date:** Subtask 1gk.2 (Week 2-3)  
**Contingency:**
If implementation too complex, create phased approach:
- Phase 2a: Required fields only (id, about, participants)
- Phase 2b: Common optional fields (chat_photo, notify_settings)
- Phase 2c: Remaining fields

---

### R3: Cache Deadlock on Concurrent Access

**ID:** R3  
**Type:** DEADLOCK  
**Status:** OPEN  
**Impact:** MEDIUM  
**Likelihood:** LOW

**Description:**
Caches use `Arc<parking_lot::Mutex<T>>` for thread-safe access. Deadlock could occur if:
1. Task A locks UserCache, then attempts to lock DialogCache
2. Task B locks DialogCache, then attempts to lock UserCache
3. Circular wait condition occurs

**Affected Components:**
- `user_manager/src/cache.rs` - UserCache
- `dialog_manager/src/cache.rs` - DialogCache
- `photo_downloader/src/cache.rs` - PhotoCache

**Mitigation Strategy:**
1. Never lock multiple mutexes simultaneously
2. Use try_lock with timeout
3. Implement lock ordering protocol if multiple locks needed
4. Add loom tests for concurrency verification
5. Use async-aware synchronization (tokio::sync::Mutex) where appropriate

**Owner:** Developer  
**Due Date:** Subtask 1gk.2 (Week 2-3)  
**Contingency:**
If deadlock occurs, refactor to use single-threaded async runtime with message passing (actor pattern).

---

### R4: Access Hash Missing for Users/Channels

**ID:** R4  
**Type:** UNRESOLVED_API  
**Status:** OPEN  
**Impact:** HIGH  
**Likelihood:** MEDIUM

**Description:**
InputUser and InputChannel require access_hash for queries. Missing access_hash prevents querying users/channels from server. Need to determine:
1. Where do access hashes come from initially?
2. How are they stored and updated?
3. What error to return if access_hash is missing?

**Affected Components:**
- `user_manager/src/lib.rs` - fetch_user(), fetch_full_user()
- `dialog_manager/src/lib.rs` - load_full_channel()

**Mitigation Strategy:**
1. Store access_hash alongside User/Channel data
2. Update access_hash from incoming User/Channel objects
3. Return clear error: `NetworkError::InvalidAccessHash(user_id)`
4. Document access_hash requirements in API docs
5. Implement "user discovery" fallback: use InputUserEmpty for unknown cases

**Owner:** Analyst (investigation), Developer (implementation)  
**Due Date:** Phase 0.5 (TL Schema Verification)  
**Contingency:**
If access_hash unavailable, implement peer resolution:
- Use InputPeer::user_from_message for users in messages
- Use InputUser::self() for current user
- Return helpful error for other cases

---

### R5: Photo Download Memory Bloat

**ID:** R5  
**Type:** MEMORY_LEAK  
**Status:** OPEN  
**Impact:** MEDIUM  
**Likelihood:** MEDIUM

**Description:**
Photo cache could consume unbounded memory if:
1. Many unique photos are downloaded
2. Photos are not evicted from cache
3. Photo cache LRU is not working correctly
4. Photo size is larger than expected

**Affected Components:**
- `photo_downloader/src/cache.rs` - PhotoCache

**Memory Estimates:**
- Small photo (thumbnail): ~10 KB
- Medium photo: ~100 KB
- Large photo: ~1 MB
- 1000 cached photos: ~100 MB (if all medium)

**Mitigation Strategy:**
1. Limit cache size to 100 MB (configurable)
2. Use LruCache with proper eviction
3. Track cache size in bytes (not count)
4. Add cache stats monitoring
5. Implement manual cache clearing API
6. Limit photo size to 5 MB (configurable)

**Owner:** Developer  
**Due Date:** Subtask 1gk.3 (Week 4)  
**Contingency:**
If memory bloat occurs, reduce cache size to 50 MB or implement disk caching.

---

### R6: Participant List Pagination Overflow

**ID:** R6  
**Type:** PERFORMANCE  
**Status:** OPEN  
**Impact:** MEDIUM  
**Likelihood:** LOW

**Description:**
Channels can have 10,000+ participants. Fetching all participants at once could:
1. Cause memory issues
2. Exceed rate limits
3. Take very long to complete
4. Timeout the request

**Affected Components:**
- `dialog_manager/src/lib.rs` - load_participants()

**Mitigation Strategy:**
1. Implement proper pagination (offset/limit)
2. Default limit: 100 participants per request
3. Use async streaming for large lists
4. Implement request queue with backoff
5. Cache participants incrementally
6. Add progress callbacks for UI

**Owner:** Developer  
**Due Date:** Subtask 1gk.2 (Week 2-3)  
**Contingency:**
If pagination too complex, limit to first 1000 participants for MVP.

---

### R7: Unsafe Code in TL Deserialization

**ID:** R7  
**Type:** TYPE_SAFETY  
**Status:** OPEN  
**Impact:** HIGH  
**Likelihood**: LOW

**Description:**
TL deserialization may require unsafe code for:
1. Reading bytes from buffer without bounds checking
2. Transmuting bytes to types
3. Parsing variable-length integers

**Affected Components:**
- `types/src/tl.rs` - TlHelper
- All TL deserialization implementations

**Mitigation Strategy:**
1. Use `bytes::Bytes` which does bounds checking
2. Avoid `unsafe` code if possible
3. If `unsafe` is required, add safety documentation
4. Add fuzzing tests (libFuzzer) for deserialization
5. Use `std::io::Cursor` or similar safe wrappers

**Owner:** Developer  
**Due Date:** Phase 0.5 (TL Schema Verification)  
**Contingency:**
If unsafe code required, create separate audit task for review.

---

### R8: FileDownloader Interface Mismatch

**ID:** R8  
**Type:** UNRESOLVED_API  
**Status:** OPEN  
**Impact:** MEDIUM  
**Likelihood:** MEDIUM

**Description:**
FileDownloader may not match PhotoDownloader's needs:
1. FileDownloader expects `FullRemoteFileLocation`
2. Photo types use `InputPhotoFileLocation`
3. Conversion layer may be needed
4. Encryption keys may be required

**Affected Components:**
- `photo_downloader/src/lib.rs` - PhotoDownloader

**Mitigation Strategy:**
1. Create adapter to convert InputPhotoFileLocation to FullRemoteFileLocation
2. Implement photo-specific download logic if needed
3. Handle encryption keys for encrypted photos
4. Add clear error for unsupported photo types

**Owner:** Developer  
**Due Date:** Subtask 1gk.3 (Week 4)  
**Contingency:**
If adapter too complex, implement custom photo download logic using NetQuery directly.

---

### R9: Cache Invalidation Race Condition

**ID:** R9  
**Type:** TYPE_SAFETY  
**Status:** OPEN  
**Impact:** LOW  
**Likelihood:** MEDIUM

**Description:**
Cache invalidation during read could cause:
1. Read of partially invalidated data
2. Use-after-free in cache lookups
3. Inconsistent cache state

**Affected Components:**
- All cache implementations

**Mitigation Strategy:**
1. Use `Arc` for cached values (clone on read)
2. Invalidate by expiration (TTL) instead of manual removal
3. Use version numbers for cache entries
4. Test with high concurrency (1000+ concurrent tasks)

**Owner:** Developer  
**Due Date:** Subtask 1gk.2 (Week 2-3)  
**Contingency:**
If race conditions occur, use single-threaded cache with async mutex.

---

### R10: Network Timeout Deadlock

**ID:** R10  
**Type:** DEADLOCK  
**Status:** OPEN  
**Impact:** MEDIUM  
**Likelihood:** LOW

**Description:**
Network requests use oneshot channels for async/await bridging. If:
1. Network query is sent
2. Callback is never invoked (network failure)
3. Oneshot receiver waits forever
4. Task hangs indefinitely

**Affected Components:**
- All network client implementations

**Mitigation Strategy:**
1. Always use `timeout()` on network requests
2. Default timeout: 30 seconds
3. Return clear timeout error
4. Log timeout for debugging
5. Implement request cancellation

**Owner:** Developer  
**Due Date:** Subtask 1gk.1 (Week 1)  
**Contingency:**
If timeouts too frequent, increase to 60 seconds or implement retry logic.

---

## Risk Summary

### By Category

| Category | Count | Open | Mitigated | Blocked |
|----------|-------|------|-----------|---------|
| UNRESOLVED_API | 4 | 4 | 0 | 0 |
| DEADLOCK | 2 | 2 | 0 | 0 |
| TYPE_SAFETY | 2 | 2 | 0 | 0 |
| PERFORMANCE | 1 | 1 | 0 | 0 |
| MEMORY_LEAK | 1 | 1 | 0 | 0 |
| **TOTAL** | **10** | **10** | **0** | **0** |

### By Priority

| Priority | Count | Risk IDs |
|----------|-------|----------|
| CRITICAL | 0 | - |
| HIGH | 5 | R1, R2, R4, R5, R7 |
| MEDIUM | 5 | R3, R6, R8, R9, R10 |
| LOW | 0 | - |

### By Likelihood

| Likelihood | Count | Risk IDs |
|------------|-------|----------|
| HIGH | 2 | R2, R4 |
| MEDIUM | 6 | R1, R3, R5, R7, R8, R9 |
| LOW | 2 | R6, R10 |

---

## Risk Review Process

### Frequency
- **Daily:** Review OPEN risks with HIGH impact
- **Weekly:** Review all OPEN risks
- **Phase Gates:** Full risk assessment

### Triggers for Review
- Risk status changes (OPEN â†’ MITIGATED)
- New risks discovered
- Timeline deviation > 20%
- Test failures reveal new issues

### Escalation Path
1. **Owner** handles risk mitigation
2. **Phase Lead** reviews blocked risks
3. **Project Manager** escalates HIGH impact risks
4. **Tech Lead** makes final call on CRITICAL risks

---

## Action Items

### Immediate (Before Phase 2 Start)
- [ ] Verify all TL constructor IDs (R1)
- [ ] Create golden test vectors (R1)
- [ ] Investigate access_hash lifecycle (R4)
- [ ] Create PhotoDownloader crate (R8)

### Subtask 1gk.1 (User Profile Display)
- [ ] Implement GetFullUserRequest with verified constructor ID (R1)
- [ ] Add timeout to all network requests (R10)
- [ ] Test cache concurrent access (R3)
- [ ] Create adapter for access_hash retrieval (R4)

### Subtask 1gk.2 (Chat Participant Loading)
- [ ] Implement ChatFull with all 20+ fields (R2)
- [ ] Add loom tests for cache deadlock (R3)
- [ ] Implement participant pagination (R6)
- [ ] Test cache invalidation race conditions (R9)

### Subtask 1gk.3 (Profile Photo Download)
- [ ] Implement PhotoCache with size limit (R5)
- [ ] Create FileDownloader adapter (R8)
- [ ] Add photo size limit validation (R5)
- [ ] Test memory usage with 1000+ photos (R5)

### Continuous
- [ ] Monitor cache sizes in production (R5)
- [ ] Track network timeout rates (R10)
- [ ] Update risk register weekly

---

## Success Criteria for Risk Mitigation

### Phase 2 Complete
- R1: All TL constructor IDs verified
- R2: ChatFull implemented with 80%+ fields
- R3: Loom tests passing for cache
- R4: Access hash flow documented
- R5: Photo cache limited to 100 MB
- R6: Pagination working for 10k+ participants
- R7: Unsafe code audited (if any)
- R8: PhotoDownloader integrated
- R9: Cache tests passing with high concurrency
- R10: All network requests have timeout

### All Risks Mitigated
- 0 UNRESOLVED_API risks remaining
- 0 DEADLOCK risks remaining
- All HIGH impact risks mitigated
- Test coverage > 70% for risky code

---

**Last Updated:** 2026-01-21
**Next Review:** After Phase 0.5 (TL Schema Verification)
