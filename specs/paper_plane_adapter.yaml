# Specification: paper_plane_adapter Crate
## TDLib Compatibility Adapter for Paper Plane GUI Client

```yaml
module: paper_plane_adapter
path: crates/paper_plane_adapter
language: rust
complexity: medium-high
estimated_loc: 1140

purpose: |
  Adapter crate providing TDLib-compatible JSON API for paper-plane GUI client.
  Bridges async rustgram managers to JSON-based TDLib API pattern.

dependencies:
  internal:
    - client_actor      # Arc<ClientActor> storage per client_id
    - auth_manager      # Authentication state queries
    - user_manager      # User profile operations
    - messages_manager  # Message sending/receiving
    - dialog_manager    # Dialog operations
    - types             # TL schema types (UserId, ChatId, etc.)
  
  external:
    - async-channel: "2.0"    # Thread-safe glib <-> tokio bridge
    - serde: "1.0"            # JSON serialization
    - serde_json: "1.0"       # JSON (de)serialization
    - tokio: {workspace}      # Async runtime
    - thiserror: "2.0"        # Error derivation
    - tracing: "0.1"          # Logging

public_api:
  main_struct:
    name: "RustgramClient"
    type: "struct"
    responsibility: "TDLib-compatible client facade"
    
    methods:
      - name: "create"
        signature: "pub async fn create(config: ClientConfig) -> Result<ClientId, AdapterError>"
        description: |
          Create new client instance with TDLib-compatible configuration.
          Initializes ClientActor and registers in client registry.
        tdlib_equivalent: "td_create_client_id"
        returns: "Unique client identifier for subsequent calls"
        
      - name: "send_request"
        signature: "pub async fn send_request(&self, method: &str, json: &str, client_id: ClientId) -> Result<String, AdapterError>"
        description: |
          Send JSON-RPC request and receive JSON response.
          Maps JSON methods to async manager calls.
        tdlib_equivalent: "td_send"
        accepts:
          - method: TDLib JSON method name (e.g., "sendMessage")
          - json: Method parameters as JSON object
          - client_id: Target client instance
        returns: "JSON response string"
        
      - name: "receive"
        signature: "pub fn receive(&self, client_id: ClientId) -> Option<(Update, ClientId)>"
        description: |
          Receive pending update for client.
          Non-blocking - returns None if no updates available.
        tdlib_equivalent: "td_receive"
        returns: "Option of (Update JSON, client_id)"
        
      - name: "execute"
        signature: "pub fn execute(&self, method: &str, json: &str) -> Result<String, AdapterError>"
        description: |
          Synchronous request (bypasses queue).
          Used for queries that don't require network.
        tdlib_equivalent: "td_execute"
        
      - name: "destroy"
        signature: "pub async fn destroy(&self, client_id: ClientId) -> Result<(), AdapterError>"
        description: |
          Gracefully shutdown client instance.
          Removes from registry and stops ClientActor.
        tdlib_equivalent: "td_destroy_client_id"

  supporting_types:
    - name: "ClientConfig"
      type: "struct"
      fields:
        - name: "api_id"
          type: "i32"
          description: "Telegram API ID"
        - name: "api_hash"
          type: "String"
          description: "Telegram API hash"
        - name: "database_path"
          type: "String"
          description: "Path to TDLib database"
        - name: "files_directory"
          type: "String"
          description: "Directory for downloaded files"
        - name: "use_test_dc"
          type: "bool"
          description: "Use test datacenter"
          
    - name: "ClientId"
      type: "struct"
      representation: "Newtype around i32"
      purpose: "Type-safe client identifier matching TDLib"
      derives: "[Copy, Clone, Debug, PartialEq, Eq, Hash]"
      
    - name: "AdapterError"
      type: "enum"
      variants:
        - InvalidJson(String)
        - ManagerNotAvailable(String)
        - AuthFailed(String)
        - NetworkError(String)
        - InvalidClientId
        - UnknownMethod(String)
        - SerializationError(String)
      derives: "[Debug, Error, thiserror::Error]"

internal_modules:
  - name: "client"
    file: "src/client.rs"
    responsibility: |
      Client lifecycle management:
      - Store Arc<ClientActor> per ClientId in HashMap
      - Generate unique ClientId instances
      - Handle client creation/destruction
    types:
      - ClientRegistry: "HashMap<ClientId, Arc<ClientActor>>"
      - ClientIdGenerator: "AtomicI32 for unique IDs"
      
  - name: "request"
    file: "src/request.rs"
    responsibility: |
      JSON to manager request mapping:
      - Parse TDLib JSON methods
      - Map to async manager calls
      - Serialize responses to JSON
    key_mappings:
      - "getMe" -> UserManager::get_me()
      - "sendMessage" -> MessagesManager::send_message()
      - "getChats" -> DialogManager::load_dialogs()
      - "getHistory" -> MessagesManager::get_history()
      - "setAuthenticationPhoneNumber" -> AuthManager::set_phone_number()
      - "checkAuthenticationCode" -> AuthManager::check_code()
      - "checkAuthenticationPassword" -> AuthManager::check_password()
      
  - name: "update"
    file: "src/update.rs"
    responsibility: |
      Update bridging glib <-> tokio:
      - Subscribe to ClientActor update channel
      - Convert rustgram Update -> TDLib JSON format
      - Thread-safe delivery via async_channel
      - Buffer updates per client
      
  - name: "state"
    file: "src/state.rs"
    responsibility: |
      Auth state translation layer:
      - Map TDLib authorizationState enums
      - Translate to/from rustgram AuthManager states
    state_map:
      - "authorizationStateWaitPhoneNumber" -> State::WaitPhoneNumber
      - "authorizationStateWaitCode" -> State::WaitCode
      - "authorizationStateWaitPassword" -> State::WaitPassword
      - "authorizationStateReady" -> State::Ok

data_flow:
  request_flow:
    - from: "paper-plane GUI (glib thread)"
      to: "RustgramClient::send_request()"
      via: "JSON-RPC over FFI"
    - from: "RustgramClient"
      to: "request::Mapper"
      via: "Method dispatch"
    - from: "request::Mapper"
      to: "Manager (auth/user/messages/dialog)"
      via: "Async method call"
    - from: "Manager"
      to: "ClientActor"
      via: "TL request/response"
    - from: "ClientActor"
      to: "Network"
      via: "MTProto"
      
  update_flow:
    - from: "Network"
      to: "ClientActor"
      via: "NetQuery callback"
    - from: "ClientActor"
      to: "Update channel"
      via: "tokio::sync::mpsc"
    - from: "Update channel"
      to: "update::Bridge"
      via: "async_channel"
    - from: "update::Bridge"
      to: "paper-plane GUI"
      via: "JSON over FFI"

error_handling:
  strategy: "Result<T, AdapterError> throughout"
  
  error_mapping:
    - source: "serde_json::Error"
      maps_to: "AdapterError::InvalidJson"
      
    - source: "Manager not found in registry"
      maps_to: "AdapterError::ManagerNotAvailable"
      
    - source: "AuthManager errors"
      maps_to: "AdapterError::AuthFailed"
      
    - source: "Network errors"
      maps_to: "AdapterError::NetworkError"
      
    - source: "Unknown TDLib method"
      maps_to: "AdapterError::UnknownMethod"

testing_strategy:
  unit_tests:
    - target: "70% coverage minimum"
    - focus:
      - ClientId generation/uniqueness
      - Request mapping accuracy
      - Update conversion (rustgram -> TDLib JSON)
      - Error handling paths
      
  integration_tests:
    - "Mock client_actor for request/response"
    - "Test full flow: JSON -> Manager -> Response"
    - "Test update delivery through async_channel"
    
  property_tests:
    - "ClientId uniqueness"
    - "JSON round-trip (request <-> response)"
    
  examples:
    - "Client creation and destruction"
    - "Authentication flow (phone -> code -> password)"
    - "Message sending and receiving"

tdlib_compatibility:
  api_surface:
    - "JSON-RPC over FFI (td_send, td_receive)"
    - "JSON request/response format"
    - "Update delivery via polling"
    
  differences:
    - "No C FFI layer (pure Rust adapter)"
    - "tokio runtime (not glib main loop)"
    - "async_channel for thread-safe updates"

constraints:
  - "ZERO unwrap() in production code"
  - "Result/Option for all fallible operations"
  - "Thread-safe: multiple clients concurrent access"
  - "Non-blocking receive() for glib compatibility"
  
success_criteria:
  - "Min 25 tests, target 40"
  - "Coverage 70% min, 80% target"
  - "0 clippy warnings"
  - "0 unwrap() in production"
  - "Supports paper-plane's TDLib method subset"
```

## Implementation Batches

### Batch 1: Crate Structure (80 LOC)
- `Cargo.toml` with dependencies
- `src/lib.rs` with public API
- `src/error.rs` with `AdapterError`
- Basic scaffolding tests

### Batch 2: Client Wrapper (200 LOC)
- `src/client.rs` with `ClientRegistry`
- `ClientId` type and generator
- `create()` and `destroy()` methods
- Registry management tests

### Batch 3: Request Mapper (350 LOC)
- `src/request.rs` with `RequestMapper`
- Method -> Manager mapping logic
- JSON parsing and response serialization
- Core TDLib methods (auth, messages, dialogs)

### Batch 4: Update Bridge (180 LOC)
- `src/update.rs` with `UpdateBridge`
- async_channel integration
- Update conversion (rustgram -> TDLib JSON)
- Poll-based `receive()` method

### Batch 5: State Translation (80 LOC)
- `src/state.rs` with auth state mapping
- TDLib <-> rustgram state conversion

### Batch 6: Integration Tests (250 LOC)
- Full auth flow tests
- Message send/receive tests
- Multi-client tests
- Error scenarios

## TDLib Method Support (Paper Plane Subset)

Based on paper-plane usage analysis:
- Authentication: setAuthenticationPhoneNumber, checkAuthenticationCode, checkAuthenticationPassword
- Users: getMe, getUser, getUserFull
- Messages: sendMessage, getMessages, getHistory
- Chats: getChats, getChat
- Files: downloadFile
