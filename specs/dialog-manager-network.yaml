# Technical Specification: DialogManager Network Integration
**Epic**: rustgram-client-4gl
**Version**: 1.0
**Date**: 2026-01-19
**Status**: Draft

---

## 1. Overview

### 1.1 Purpose
Integrate DialogManager with the `rustgram-net` crate to enable network operations for loading dialogs from Telegram servers.

### 1.2 Scope
- Add network client integration layer
- Implement TL request/response types for dialog operations
- Add async methods for dialog loading, creation, and metadata updates
- Implement caching with TTL support
- Add comprehensive error handling with retry logic
- Achieve 70%+ test coverage with 40+ tests

### 1.3 Current State
- **DialogManager**: 28 tests, 26% coverage
- **Architecture**: Synchronous with `Arc<RwLock<T>>` state
- **Network**: No existing network integration
- **Location**: `crates/dialog_manager/src/lib.rs`

---

## 2. Module Structure

### 2.1 New Files

```
crates/dialog_manager/
├── src/
│   ├── lib.rs              # Existing (modify: add network module)
│   ├── error.rs            # Existing (modify: add network errors)
│   ├── network.rs          # NEW: Network client wrapper
│   ├── tl_types.rs         # NEW: TL request/response types
│   └── cache.rs            # NEW: Caching layer
├── Cargo.toml              # MODIFY: Add rustgram-net dependency
└── tests/
    └── network_integration_test.rs  # NEW: Integration tests
```

### 2.2 Module Dependencies

```mermaid
graph TD
    A[dialog_manager] --> B[rustgram-net]
    A --> C[rustgram-types]
    A --> D[rustgram-chat-manager]
    B --> E[tokio]
    B --> F[bytes]
    C --> G[serde]
```

---

## 3. Public API Definitions

### 3.1 Network Client Module (`network.rs`)

```rust
//! Network client integration for DialogManager.
//!
//! Bridges DialogManager with the net crate's query dispatcher.

use rustgram_net::{
    NetQuery, NetQueryDispatcher, QueryError, AuthFlag, GzipFlag, NetQueryType
};
use tokio::sync::oneshot;
use std::sync::Arc;
use std::time::Duration;

/// Network client wrapper for DialogManager.
///
/// Provides async/await interface over callback-based NetQuery system.
pub struct NetworkClient {
    /// Query dispatcher for sending requests
    dispatcher: Arc<NetQueryDispatcher>,
    /// Request timeout
    timeout: Duration,
    /// Maximum retry attempts
    max_retries: usize,
}

impl NetworkClient {
    /// Creates a new network client.
    pub fn new(dispatcher: Arc<NetQueryDispatcher>) -> Self;
    
    /// Sends a query and waits for response.
    pub async fn send_query(
        &self,
        query: NetQuery,
    ) -> Result<bytes::Bytes, DialogError>;
    
    /// Sends a query with custom timeout.
    pub async fn send_query_with_timeout(
        &self,
        query: NetQuery,
        timeout: Duration,
    ) -> Result<bytes::Bytes, DialogError>;
}

/// Query ID counter for generating unique query IDs.
static NEXT_QUERY_ID: AtomicU64 = AtomicU64::new(1);
```

### 3.2 TL Types Module (`tl_types.rs`)

```rust
//! TL (Type Language) types for dialog operations.
//!
//! Defines request/response types for Telegram's messages.getDialogs API.

use bytes::Bytes;
use serde::{Deserialize, Serialize};
use rustgram_types::{DialogId, ChatId, UserId, ChannelId, InputPeer};

/// Request to load dialogs from server.
///
/// Corresponds to TL schema: `messages.getDialogs#191ba9c5`
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetDialogsRequest {
    /// Offset date for pagination
    pub offset_date: i32,
    /// Offset dialog ID for pagination
    pub offset_id: i32,
    /// Offset peer for pagination
    pub offset_peer: InputPeer,
    /// Maximum number of dialogs to return
    pub limit: i32,
    /// Hash for caching
    pub hash: i64,
}

/// Response containing dialogs from server.
///
/// Corresponds to TL schema variants:
/// - `messages.dialogs#3646d098`
/// - `messages.dialogsSlice#1834175b`
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetDialogsResponse {
    /// List of dialogs
    pub dialogs: Vec<Dialog>,
    /// List of messages
    pub messages: Vec<Message>,
    /// List of chats
    pub chats: Vec<Chat>,
    /// List of users
    pub users: Vec<User>,
}

/// Simplified dialog representation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Dialog {
    /// Dialog ID
    pub id: DialogId,
    /// Peer information
    pub peer: Peer,
    /// Top message ID
    pub top_message: i32,
    /// Unread count
    pub unread_count: i32,
    /// Notification settings
    pub notify_settings: NotifyPeer,
    /// Read inbox date
    pub read_inbox_max_id: i32,
    /// Read outbox date
    pub read_outbox_max_id: i32,
}

/// Pagination token for dialog loading.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct DialogPagination {
    /// Last dialog date
    pub offset_date: i32,
    /// Last dialog ID
    pub offset_id: i32,
    /// Last peer
    pub offset_peer: InputPeer,
}

/// Request to create a new chat.
///
/// Corresponds to TL schema: `messages.createChat#cbdef11d`
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateChatRequest {
    /// User IDs to add to chat
    pub user_ids: Vec<UserId>,
    /// Chat title
    pub title: String,
    /// TTL period (optional)
    pub ttl_period: Option<i32>,
}

/// Request to update dialog title.
///
/// Corresponds to TL schema: `messages.editChatTitle#dc452855`
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateTitleRequest {
    /// Chat ID
    pub chat_id: ChatId,
    /// New title
    pub title: String,
}

/// Request to update dialog photo.
///
/// Corresponds to TL schema: `messages.editChatPhoto#ca4c7978`
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdatePhotoRequest {
    /// Chat ID
    pub chat_id: ChatId,
    /// Photo input peer
    pub photo: InputPeer,
}
```

### 3.3 Cache Module (`cache.rs`)

```rust
//! Caching layer for dialog data.
//!
//! Implements TTL-based caching with automatic invalidation.

use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, Instant};
use rustgram_types::DialogId;

/// Cache entry with TTL.
#[derive(Debug, Clone)]
struct CacheEntry<T> {
    /// Cached value
    value: T,
    /// Expiration timestamp
    expires_at: Instant,
}

/// Dialog cache with TTL support.
pub struct DialogCache {
    /// Dialog list cache
    dialogs: Arc<parking_lot::Mutex<Option<CacheEntry<Vec<Dialog>>>>>,
    /// Individual dialog metadata cache
    metadata: Arc<parking_lot::Mutex<HashMap<DialogId, CacheEntry<DialogMetadata>>>>,
    /// Default TTL for cache entries
    default_ttl: Duration,
}

impl DialogCache {
    /// Creates a new cache with default TTL (5 minutes).
    pub fn new() -> Self;
    
    /// Creates a new cache with custom TTL.
    pub fn with_ttl(ttl: Duration) -> Self;
    
    /// Gets cached dialogs if not expired.
    pub fn get_dialogs(&self) -> Option<Vec<Dialog>>;
    
    /// Sets cached dialogs with TTL.
    pub fn set_dialogs(&self, dialogs: Vec<Dialog>);
    
    /// Gets cached metadata if not expired.
    pub fn get_metadata(&self, id: DialogId) -> Option<DialogMetadata>;
    
    /// Sets cached metadata with TTL.
    pub fn set_metadata(&self, id: DialogId, metadata: DialogMetadata);
    
    /// Invalidates all cache entries.
    pub fn invalidate_all(&self);
    
    /// Invalidates a specific dialog.
    pub fn invalidate_dialog(&self, id: DialogId);
    
    /// Returns cache statistics.
    pub fn stats(&self) -> CacheStats;
}

/// Cache statistics.
#[derive(Debug, Clone, PartialEq)]
pub struct CacheStats {
    /// Number of cached dialogs
    pub dialog_count: usize,
    /// Number of cached metadata entries
    pub metadata_count: usize,
    /// Cache hit rate (0.0 to 1.0)
    pub hit_rate: f64,
}
```

### 3.4 Extended Error Types

```rust
// Add to error.rs

/// Errors that can occur in dialog operations.
#[derive(Debug, Clone, PartialEq, Error)]
pub enum DialogError {
    // ... existing variants ...
    
    /// Network error.
    #[error("network error: {0}")]
    NetworkError(String),
    
    /// Query execution failed.
    #[error("query failed: {0}")]
    QueryFailed(#[from] QueryError),
    
    /// Request timeout.
    #[error("request timeout after {0:?}")]
    Timeout(Duration),
    
    /// Authentication required.
    #[error("authentication required for this operation")]
    AuthRequired,
    
    /// Rate limited.
    #[error("rate limited: retry after {0}s")]
    RateLimited(u32),
    
    /// Invalid TL data.
    #[error("invalid TL data: {0}")]
    InvalidTlData(String),
    
    /// Serialization error.
    #[error("serialization error: {0}")]
    SerializationError(String),
    
    /// Deserialization error.
    #[error("deserialization error: {0}")]
    DeserializationError(String),
    
    /// Cache error.
    #[error("cache error: {0}")]
    CacheError(String),
}
```

---

## 4. Network Integration Points

### 4.1 Query Lifecycle

```mermaid
sequenceDiagram
    participant DM as DialogManager
    participant NC as NetworkClient
    participant NQD as NetQueryDispatcher
    participant Server as Telegram Server
    
    DM->>NC: load_dialogs(params)
    NC->>NC: Create NetQuery
    NC->>NQD: dispatch(query)
    NQD->>Server: Send request
    Server-->>NQD: Response
    NQD-->>NC: on_result callback
    NC-->>DM: Result<Bytes>
    DM->>DM: Parse TL response
    DM-->>Caller: Vec<Dialog>
```

### 4.2 Authentication Flow

```rust
// All dialog operations require AuthFlag::On
let query = NetQuery::new(
    query_id,
    serialized_request,
    dc_id,
    NetQueryType::Common,
    AuthFlag::On,  // Required for dialog operations
    GzipFlag::Off,
    tl_constructor,
);
```

### 4.3 Error Mapping

| NetQuery Error | DialogError | Retryable |
|----------------|-------------|-----------|
| QueryError::WithMessage { code: 500 } | NetworkError | Yes (3x) |
| QueryError::WithMessage { code: 502 } | NetworkError | Yes (3x) |
| QueryError::WithMessage { code: 429 } | RateLimited | No (use delay) |
| QueryError::Special(Resend) | NetworkError | Yes (auto) |
| QueryError::Special(Canceled) | Timeout | No |
| Timeout (oneshot) | Timeout | No |

---

## 5. Implementation Methods

### 5.1 DialogManager Extensions

```rust
// Add to DialogManager in lib.rs

impl DialogManager {
    /// Loads dialogs from the server.
    ///
    /// # Arguments
    ///
    /// * `pagination` - Pagination parameters
    /// * `limit` - Maximum dialogs to return (1-100)
    ///
    /// # Returns
    ///
    /// Paginated dialog list with continuation token
    ///
    /// # Errors
    ///
    /// Returns error if:
    /// - Not authenticated
    /// - Network request fails
    /// - TL data is invalid
    pub async fn load_dialogs(
        &self,
        pagination: Option<DialogPagination>,
        limit: usize,
    ) -> Result<(Vec<Dialog>, Option<DialogPagination>)>;

    /// Creates a new group chat.
    ///
    /// # Arguments
    ///
    /// * `user_ids` - Users to add to chat
    /// * `title` - Chat title
    ///
    /// # Returns
    ///
    /// ID of created dialog
    pub async fn create_dialog(
        &self,
        user_ids: Vec<UserId>,
        title: String,
    ) -> Result<DialogId>;

    /// Updates dialog title on server.
    ///
    /// # Arguments
    ///
    /// * `dialog_id` - Dialog to update
    /// * `title` - New title
    pub async fn update_dialog_title(
        &self,
        dialog_id: DialogId,
        title: String,
    ) -> Result<()>;

    /// Updates dialog photo on server.
    ///
    /// # Arguments
    ///
    /// * `dialog_id` - Dialog to update
    /// * `photo` - New photo
    pub async fn update_dialog_photo(
        &self,
        dialog_id: DialogId,
        photo: InputPeer,
    ) -> Result<()>;

    /// Reloads a dialog from server (cache refresh).
    ///
    /// # Arguments
    ///
    /// * `dialog_id` - Dialog to reload
    pub async fn reload_dialog(
        &self,
        dialog_id: DialogId,
    ) -> Result<Dialog>;
}
```

### 5.2 Caching Strategy

```rust
// Cache configuration
const DEFAULT_CACHE_TTL: Duration = Duration::from_secs(300); // 5 minutes
const DIALOG_LIST_TTL: Duration = Duration::from_secs(60);    // 1 minute
const METADATA_TTL: Duration = Duration::from_secs(300);      // 5 minutes

// Cache invalidation triggers:
// 1. TTL expiration
// 2. Explicit reload_dialog() call
// 3. Update operations (title, photo)
// 4. New message received
// 5. Manual invalidate() call
```

---

## 6. Testing Strategy

### 6.1 Test Structure

```
dialog_manager/tests/
├── network_unit_test.rs         # Unit tests for network module
├── tl_types_test.rs             # TL serialization tests
├── cache_test.rs                # Cache behavior tests
├── error_handling_test.rs       # Error mapping tests
├── integration_test.rs          # End-to-end tests (mocked)
└── pagination_test.rs           # Pagination logic tests
```

### 6.2 Test Categories

#### Unit Tests (20+ tests)
- Network client creation and configuration
- Query serialization
- TL type serialization/deserialization
- Cache get/set/invalidate operations
- Cache TTL expiration
- Error type conversions
- Pagination token creation/parsing

#### Integration Tests (15+ tests)
- load_dialogs() with mocked network
- create_dialog() success/failure paths
- update_dialog_title() with cache sync
- update_dialog_photo() with cache sync
- reload_dialog() cache refresh
- Error handling with network failures
- Retry logic for transient errors
- Rate limiting handling

#### Edge Cases (5+ tests)
- Empty dialog list
- Pagination edge cases (first page, last page)
- Very large titles (truncation)
- Concurrent cache access
- Network timeout handling

### 6.3 Mock Network

```rust
#[cfg(test)]
mod mock_network {
    use super::*;
    
    /// Mock query dispatcher for testing.
    pub struct MockDispatcher {
        response: Arc<Mutex<Option<Bytes>>>,
        error: Arc<Mutex<Option<QueryError>>>,
    }
    
    impl MockDispatcher {
        pub fn with_response(response: Bytes) -> Self;
        pub fn with_error(error: QueryError) -> Self;
        pub fn with_delay(response: Bytes, delay: Duration) -> Self;
    }
}
```

---

## 7. Success Criteria

### 7.1 Functional Requirements
- ✅ `load_dialogs()` successfully fetches dialogs from mocked network
- ✅ Pagination works correctly across multiple pages
- ✅ `create_dialog()` creates new chats
- ✅ `update_dialog_title()` syncs with server
- ✅ Cache invalidates on TTL expiration
- ✅ All errors properly mapped from QueryError to DialogError

### 7.2 Code Quality Metrics
- **Test Count**: ≥ 40 tests (current: 28, need: +12)
- **Code Coverage**: ≥ 70% (current: 26%, need: +44%)
- **Cyclomatic Complexity**: ≤ 10 per function
- **Clippy Warnings**: 0
- **Production unwrap()**: 0

### 7.3 Performance Requirements
- Network requests timeout after 30 seconds
- Cache hit rate ≥ 80% in typical usage
- Retry max 3 attempts for transient errors
- Memory overhead ≤ 10MB for 1000 cached dialogs

---

## 8. Dependencies

### 8.1 Internal Dependencies
```toml
[dependencies]
rustgram-types = { path = "../types" }
rustgram-chat-manager = { path = "../chat-manager" }
rustgram-net = { path = "../net" }  # NEW

serde = { workspace = true }
thiserror = { workspace = true }
tokio = { workspace = true }
bytes = { workspace = true }

[dev-dependencies]
tokio-test = "0.4"
```

### 8.2 External Dependencies
| Crate | Version | Purpose |
|-------|---------|---------|
| tokio | 1.35 | Async runtime |
| bytes | 1.5 | Byte buffer management |
| parking_lot | 0.12 | Fast mutexes |
| serde | 1.0 | TL serialization |
| thiserror | 1.0 | Error derive macros |

---

## 9. Timeline Estimates

| Step | Estimated LOC | Time |
|------|---------------|------|
| 1. Network Client | 150-200 | 2-3 hours |
| 2. TL Types | 100-150 | 1-2 hours |
| 3. Load Dialogs | 200-250 | 3-4 hours |
| 4. Create Dialog | 150-200 | 2-3 hours |
| 5. Metadata Updates | 100-150 | 2-3 hours |
| 6. Caching | 150-200 | 2-3 hours |
| 7. Error Handling | 100-150 | 2-3 hours |
| 8. Testing | 300-400 | 4-6 hours |
| **Total** | **1,250-1,650** | **18-27 hours** |

---

## 10. Open Questions

### 10.1 TL Schema Coverage
- **Question**: What is the full TL schema for `messages.getDialogs`?
- **Impact**: Medium - May affect request/response structure
- **Decision**: Start with basic schema, extend as needed

### 10.2 Cache Coherency
- **Question**: How to handle cache updates when dialogs change externally?
- **Impact**: Low - Can defer to update notification system
- **Decision**: Use TTL-based cache for now

### 10.3 Multi-DC Support
- **Question**: Should dialogs support loading from different DCs?
- **Impact**: Low - Single DC sufficient for MVP
- **Decision**: Use main DC only for now

---

**Document Status**: ✅ Complete
**Next Step**: Phase 2.5 - Verification Gate
