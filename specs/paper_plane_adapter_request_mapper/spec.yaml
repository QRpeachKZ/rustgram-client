# Specification: Paper Plane Adapter Request Mapper
**Task ID**: rustgram-client-zwh.3
**Version**: 1.0
**Last Updated**: 2026-01-21
**Status**: Draft

---

## Overview

The Paper Plane Adapter Request Mapper provides TDLib-compatible JSON API for the Rustgram client. It maps JSON requests from the Paper Plane GUI to async manager calls and serializes responses back to JSON.

### Architecture

```
Paper Plane GUI
       │
       ├── JSON Request ──┐
       │                  ▼
       │         RequestMapper
       │                  ├── parse_json()
       │                  ├── map_to_manager_call()
       │                  │       ├── DialogManager
       │                  │       ├── MessagesManager
       │                  │       └── UserManager
       │                  ├── await response
       │                  └── serialize_json()
       │                  ▼
       └── JSON Response ←─┘
```

### Reference Implementation

Based on TDLib's `ClientJson` from `references/td/td/telegram/ClientJson.cpp`:
```cpp
void ClientJson::send(Slice request) {
  auto parsed_request = to_request(request);
  std::uint64_t extra_id = extra_id_.fetch_add(1, std::memory_order_relaxed);
  client_.send(Client::Request{extra_id, std::move(parsed_request.first)});
}

const char *ClientJson::receive(double timeout) {
  auto response = client_.receive(timeout);
  return store_string(from_response(*response.object, extra, 0));
}
```

---

## Module Specification

### Crate Structure

```
crates/paper_plane_adapter/
├── Cargo.toml
└── src/
    ├── lib.rs              # Public API: RustgramClient
    ├── request.rs          # Request types and parsing
    ├── response.rs         # Response types and serialization
    ├── mapper.rs           # JSON ↔ Manager call mapping
    ├── error.rs            # Error types
    └── tests/
        ├── request_tests.rs
        ├── mapper_tests.rs
        └── integration_tests.rs
```

### Public API

#### `RustgramClient`

```rust
use std::sync::Arc;
use tokio::sync::mpsc;

/// TDLib-compatible JSON client for Rustgram.
///
/// Provides synchronous API for async Rustgram managers.
/// Thread-safe: can be called from any thread.
pub struct RustgramClient {
    /// Request sender (sync → async bridge)
    tx: mpsc::UnboundedSender<IncomingRequest>,
    
    /// Response receiver (for poll-based API)
    rx: Arc<Mutex<mpsc::UnboundedReceiver<OutgoingResponse>>>,
    
    /// Pending requests for correlation
    pending: Arc<RwLock<HashMap<u64, RequestContext>>>,
    
    /// Next request ID
    next_id: Arc<AtomicU64>,
}

impl RustgramClient {
    /// Creates a new Rustgram client instance.
    ///
    /// # Returns
    ///
    /// Client handle for sending/receiving JSON requests.
    pub fn create() -> Arc<Self>;
    
    /// Sends a JSON request to the client.
    ///
    /// This is thread-safe and can be called from any thread.
    /// The request is queued for async processing.
    ///
    /// # Arguments
    ///
    /// * `json_request` - JSON-serialized request string
    ///
    /// # Example
    ///
    /// ```no_run
    /// let client = RustgramClient::create();
    /// client.send(r#"{"@type":"sendMessage","chat_id":123,"text":"Hello"}"#);
    /// ```
    pub fn send(&self, json_request: &str);
    
    /// Receives the next response or update.
    ///
    /// Returns NULL if timeout expires.
    ///
    /// # Arguments
    ///
    /// * `timeout` - Maximum seconds to wait
    ///
    /// # Returns
    ///
    /// JSON-serialized response or NULL
    pub fn receive(&self, timeout: f64) -> Option<String>;
    
    /// Synchronously executes a request.
    ///
    /// Only works for requests marked as "Can be called synchronously".
    ///
    /// # Arguments
    ///
    /// * `json_request` - JSON-serialized request
    ///
    /// # Returns
    ///
    /// JSON-serialized response
    pub fn execute(&self, json_request: &str) -> Result<String, Error>;
}

impl Drop for RustgramClient {
    /// Destroys the client and cleans up resources.
    fn drop(&mut self);
}
```

### Internal Types

#### `IncomingRequest`

```rust
/// A request from the client with context for correlation.
pub struct IncomingRequest {
    /// Request ID for correlation
    pub request_id: u64,
    
    /// Parsed request object
    pub request: Request,
    
    /// Client-provided extra data (echoed in response)
    pub extra: Option<String>,
    
    /// When the request was sent (for timeout)
    pub timestamp: Instant,
}
```

#### `OutgoingResponse`

```rust
/// A response to be sent to the client.
pub struct OutgoingResponse {
    /// Request ID this responds to (0 for updates)
    pub request_id: u64,
    
    /// Serialized JSON response
    pub response: String,
    
    /// Client ID (multi-client support, always 0 for now)
    pub client_id: i32,
}
```

#### `Request`

```rust
/// Parsed request type.
///
/// Each variant maps to a manager method.
#[derive(Debug, Clone)]
pub enum Request {
    // Dialog operations
    GetDialogs {
        offset_date: i32,
        offset_id: i32,
        offset_peer: InputPeer,
        limit: i32,
    },
    
    CreateDialog {
        user_ids: Vec<i64>,
        title: String,
    },
    
    UpdateDialogTitle {
        dialog_id: DialogId,
        title: String,
    },
    
    // Message operations
    SendMessage {
        chat_id: i64,
        text: String,
        reply_to_message_id: Option<i32>,
    },
    
    // User operations
    GetUsers {
        user_ids: Vec<i64>,
    },
    
    GetMe,
    
    GetUser {
        user_id: i64,
    },
    
    // Auth operations
    SendCode {
        phone_number: String,
        settings: CodeSettings,
    },
    
    SignIn {
        phone_number: String,
        phone_code_hash: String,
        phone_code: String,
    },
    
    LogOut,
}
```

#### `Response`

```rust
/// Response from a manager call.
#[derive(Debug, Clone)]
pub enum Response {
    GetDialogs {
        dialogs: Vec<Dialog>,
        next_offset: Option<Pagination>,
    },
    
    CreateDialog {
        dialog_id: DialogId,
    },
    
    SendMessage {
        message_id: MessageId,
    },
    
    GetUsers {
        users: Vec<User>,
    },
    
    GetMe {
        user: User,
    },
    
    GetUser {
        user: Option<User>,
    },
    
    SendCode {
        phone_code_hash: String,
        next_type: Option<SentCodeType>,
        timeout: Option<i32>,
    },
    
    SignIn {
        authorization: Authorization,
    },
    
    LogOut,
    
    Error {
        code: i32,
        message: String,
    },
}
```

---

## Input Schema (JSON Requests)

### Request Format

All requests follow TDLib JSON format:

```json
{
  "@type": "requestName",
  "@extra": "optional-client-data",
  "param1": "value1",
  "param2": "value2"
}
```

### Supported Requests

#### `getChats` (alias for `getDialogs`)

```json
{
  "@type": "getChats",
  "@extra": "client-request-id",
  "offset_order": "9223372036854775807",
  "offset_chat_id": 0,
  "limit": 20
}
```

**Maps to**: `DialogManager::load_dialogs()`

#### `createChat`

```json
{
  "@type": "createChat",
  "@extra": "client-request-id",
  "user_ids": [123456, 789012],
  "title": "New Group"
}
```

**Maps to**: `DialogManager::create_dialog()`

#### `sendMessage`

```json
{
  "@type": "sendMessage",
  "@extra": "client-request-id",
  "chat_id": 123456,
  "text": "Hello, world!",
  "reply_to_message_id": 789
}
```

**Maps to**: `MessagesManager::send_text()`

#### `getUsers`

```json
{
  "@type": "getUsers",
  "@extra": "client-request-id",
  "user_ids": [123456, 789012]
}
```

**Maps to**: `UserManager::fetch_users()`

#### `getMe`

```json
{
  "@type": "getMe"
}
```

**Maps to**: `UserManager::fetch_me()`

---

## Output Schema (JSON Responses)

### Response Format

```json
{
  "@type": "responseType",
  "@extra": "echoed-from-request",
  "@client_id": 0,
  "field1": "value1"
}
```

### Error Format

```json
{
  "@type": "error",
  "@extra": "echoed-from-request",
  "code": 400,
  "message": "Invalid request"
}
```

### Response Examples

#### `chats` (from `getChats`)

```json
{
  "@type": "chats",
  "@extra": "client-request-id",
  "@client_id": 0,
  "chat_ids": [123456, 789012, 345678],
  "total_count": 42
}
```

#### `message` (from `sendMessage`)

```json
{
  "@type": "message",
  "@extra": "client-request-id",
  "@client_id": 0,
  "id": 98765,
  "chat_id": 123456,
  "content": {
    "@type": "messageText",
    "text": {
      "@type": "formattedText",
      "text": "Hello, world!"
    }
  },
  "date": 1737610800
}
```

#### `users` (from `getUsers`)

```json
{
  "@type": "users",
  "@extra": "client-request-id",
  "@client_id": 0,
  "users": [
    {
      "id": 123456,
      "first_name": "Alice",
      "last_name": "Smith",
      "username": "alice",
      "phone_number": "+1234567890"
    }
  ]
}
```

---

## Error Handling

### Error Types

```rust
#[derive(Debug, thiserror::Error)]
pub enum AdapterError {
    /// JSON parsing failed
    #[error("JSON parse error: {0}")]
    JsonParse(String),
    
    /// Invalid request structure
    #[error("Invalid request: {0}")]
    InvalidRequest(String),
    
    /// Unknown request type
    #[error("Unknown request type: {0}")]
    UnknownType(String),
    
    /// Manager call failed
    #[error("Manager error: {0:?}")]
    Manager(#[from] ManagerError),
    
    /// Request timeout
    #[error("Request timeout after {0:?}")]
    Timeout(Duration),
    
    /// Response serialization failed
    #[error("Response serialization failed: {0}")]
    Serialization(String),
}
```

### Error Mapping

| Rust Error | JSON Code | JSON Message |
|------------|-----------|--------------|
| `AdapterError::JsonParse` | 400 | "Failed to parse request as JSON" |
| `AdapterError::InvalidRequest` | 400 | "Invalid request structure" |
| `AdapterError::UnknownType` | 400 | "Unknown request type" |
| `DialogError::NotFound` | 404 | "Dialog not found" |
| `MessagesManagerError::Validation` | 400 | "Message validation failed" |
| `UserManager::NetworkError` | 500 | "Network error" |
| `AdapterError::Timeout` | 408 | "Request timeout" |

---

## Dependency Matrix

### Internal Dependencies

| Crate | Version | Features | Used For |
|-------|---------|----------|----------|
| `rustgram_types` | workspace | - | `DialogId`, `UserId`, `MessageId` |
| `rustgram_dialog_manager` | workspace | network | Dialog operations |
| `rustgram_messages_manager` | workspace | - | Message operations |
| `rustgram_user_manager` | workspace | network | User operations |
| `rustgram_auth_manager` | workspace | - | Auth operations |
| `rustgram_net` | workspace | - | `NetworkClient` |

### External Dependencies

| Crate | Version | Features | Used For |
|-------|---------|----------|----------|
| `serde` | 1.0 | `derive` | Request/Response serialization |
| `serde_json` | 1.0 | - | JSON parsing |
| `tokio` | 1.0 | `sync`, `rt` | Async runtime |
| `thiserror` | 1.0 | - | Error handling |
| `tracing` | 0.1 | - | Logging |

---

## Manager API Mapping

### DialogManager

| JSON Request | Manager Method | Async |
|--------------|---------------|-------|
| `getChats` | `load_dialogs(client, pagination, limit)` | Yes |
| `createChat` | `create_dialog(client, user_ids, title)` | Yes |
| `setChatTitle` | `update_dialog_title(client, dialog_id, title)` | Yes |
| `setChatPhoto` | `update_dialog_photo(client, dialog_id, photo)` | Yes |

### MessagesManager

| JSON Request | Manager Method | Async |
|--------------|---------------|-------|
| `sendMessage` | `send_text(dialog_id, text, reply_to)` | Yes |
| `forwardMessages` | (not implemented) | - |
| `editMessageText` | (not implemented) | - |
| `deleteMessages` | (not implemented) | - |

### UserManager

| JSON Request | Manager Method | Async |
|--------------|---------------|-------|
| `getUsers` | `fetch_users(ids)` | Yes |
| `getMe` | `fetch_me()` | Yes |
| `getUser` | `get_user(id)` | Yes |
| `getUserFullInfo` | `fetch_full_user(id)` | Yes |

### AuthManager

| JSON Request | Manager Method | Async |
|--------------|---------------|-------|
| `setAuthenticationPhoneNumber` | `send_code(phone, settings)` | Yes |
| `checkAuthenticationCode` | `sign_in(phone, hash, code)` | Yes |
| `logOut` | `log_out()` | Yes |

---

## Thread Safety

### Thread Safety Guarantees

| Method | Thread Safe | Notes |
|--------|-------------|-------|
| `send()` | Yes | Uses unbounded channel |
| `receive()` | No | Must be called from single thread |
| `execute()` | Yes | Synchronous operation |

### Shared State

```rust
pub struct RustgramClient {
    // Thread-safe: Arc<Tx>
    tx: mpsc::UnboundedSender<IncomingRequest>,
    
    // Protected by Mutex for exclusive access
    rx: Arc<Mutex<mpsc::UnboundedReceiver<OutgoingResponse>>>,
    
    // Thread-safe: Arc<RwLock<HashMap>>
    pending: Arc<RwLock<HashMap<u64, RequestContext>>>,
    
    // Thread-safe: Arc<AtomicU64>
    next_id: Arc<AtomicU64>,
}
```

---

## Performance Considerations

### Throughput Targets

| Metric | Target | Notes |
|--------|--------|-------|
| Requests per second | 1000+ | Concurrent processing |
| Response latency | < 50ms | P95 for local calls |
| Memory per client | < 10MB | Excluding managers |

### Optimization Strategies

1. **Request Batching**: Combine multiple requests when possible
2. **Response Pooling**: Reuse response buffers
3. **Lazy Serialization**: Only serialize when `receive()` is called
4. **Request ID Recycling**: Reuse request IDs after timeout

---

## Testing Strategy

### Unit Tests

- JSON parsing for all request types
- JSON serialization for all response types
- Error mapping for all error variants
- Request ID generation and correlation

### Integration Tests

- Full request→manager→response flow
- Concurrent request handling
- Timeout handling
- Manager error propagation

### Compatibility Tests

- JSON format matches TDLib exactly
- Response structure matches TDLib
- Error codes match TDLib

---

## Open Questions

1. **@extra format**: TDLib uses JSON string for @extra. Should we support any JSON value?
2. **Update ordering**: Must updates be delivered in order? (affects channel design)
3. **Concurrent receive**: Should `receive()` be thread-safe? (requires mutex)
4. **Request timeout**: What should the default timeout be? (TDLib: infinite)

---

## Success Criteria

- [ ] All JSON requests parse correctly
- [ ] All manager calls map correctly
- [ ] All responses serialize to TDLib-compatible JSON
- [ ] 70%+ test coverage
- [ ] No `unwrap()` in production code
- [ ] Thread-safe `send()` from multiple threads
- [ ] Passes TDLib compatibility tests

---

**Document Status**: Draft  
**Next Review**: After Phase 2.5 (Verification Gate)
