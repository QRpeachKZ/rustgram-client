# Technical Specification: Code Quality Analysis and Remediation
# Task: rustgram-client-ma0.2
# Phase: 2 - Analysis + Plan Validation + Spec/Design
# Date: 2025-01-17

metadata:
  project: "rustgram-client"
  task_id: "rustgram-client-ma0.2"
  title: "Code Quality Analysis and unwrap()/expect() Remediation"
  version: "1.0.0"
  author: "System Analyst"
  status: "DRAFT"
  
scope:
  description: "Systematic analysis and remediation of code quality violations across 398 crates"
  
  violation_types:
    unwrap_calls:
      total_violations: 3848
      affected_files: 268
      severity: "HIGH"
      clippy_lint: "unwrap_used"
      workspace_config: "deny"
      
    expect_calls:
      total_violations: 250
      affected_files: 57
      severity: "MEDIUM"
      clippy_lint: "expect_used"
      workspace_config: "deny"
      
  target_crates:
    total_managers: 68
    categories:
      - name: "manager crates"
        count: 68
        pattern: "*_manager"
      - name: "type crates"
        count: 330
        pattern: "*_id, *_type, *_state"
  
analysis_context:
  workspace_configuration:
    file: "Cargo.toml"
    lints:
      rust:
        - "missing_docs = warn"
      clippy:
        - "all = warn"
        - "unwrap_used = deny"
        - "expect_used = deny"
    
  current_state:
    compilation_status: "FAILING"
    build_command: "cargo build --workspace"
    error_type: "Clippy lint violations"
    
  codebase_metrics:
    total_rust_files: 636
    total_crates: 398
    test_modules: 300+
    manager_crates: 68
    
violation_patterns:
  test_code:
    description: "unwrap()/expect() in #[cfg(test)] modules"
    percentage: "40%"
    examples:
      - "serde_json::to_string(...).unwrap() in serialization tests"
      - "bincode::serialize(...).unwrap() in deserialization tests"
      - "assert!(...).unwrap() in comparison tests"
    remediation_strategy: "ACCEPT - Use `.unwrap()` in tests with #[expect(clippy::unwrap_used)]"
    
  serialization:
    description: "unwrap() on serde_json/bincode operations"
    percentage: "25%"
    examples:
      - "serde_json::to_string(&value).unwrap()"
      - "serde_json::from_str::<T>(&json).unwrap()"
      - "bincode::serialize(&data).unwrap()"
    remediation_strategy: "PROPAGATE - Return Result<T, SerializationError>"
    
  actor_initialization:
    description: "unwrap() in actor/manager initialization"
    percentage: "15%"
    examples:
      - "Arc::new(RwLock::new(state)).unwrap() - should never fail"
      - "String::from_utf8(vec).unwrap() - guaranteed UTF-8"
    remediation_strategy: "DOCUMENT - Add unsafe_assert!() macro with docs"
    
  file_operations:
    description: "unwrap() on file I/O operations"
    percentage: "10%"
    examples:
      - "File::open(path).unwrap()"
      - "fs::read_to_string(path).unwrap()"
    remediation_strategy: "PROPAGATE - Return Result<T, IoError>"
    
  crypto_operations:
    description: "unwrap() in cryptographic operations"
    percentage: "5%"
    examples:
      - "key.try_into().unwrap() in crypto/rsa"
      - "Vec::from_hex(hex_str).unwrap() in encoding"
    remediation_strategy: "CUSTOM_ERROR - Return CryptoError"
    
  index_operations:
    description: "unwrap() on Vec/HashMap indexing"
    percentage: "5%"
    examples:
      - "vec.get(index).unwrap()"
      - "map.get(&key).unwrap()"
    remediation_strategy: "REFACTOR - Use get() with Option handling"

remediation_strategy:
  approach: "3-Batch Progressive Remediation"
  
  batch_1:
    name: "Non-Test Production Code"
    scope: "unwrap()/expect() in production code (excluding tests)"
    estimated_violations: 2300
    priority: "CRITICAL"
    duration: "2-3 weeks"
    
    subcategories:
      category_1_1:
        name: "Critical Path Managers"
        crates:
          - "dialog_manager (96 violations)"
          - "chat_manager (109 violations)"
          - "call_manager (115 violations)"
          - "group_call_manager (105 violations)"
        remediation_pattern: "Result<T, ManagerError>"
        
      category_1_2:
        name: "File/Network Operations"
        crates:
          - "download_manager (64 violations)"
          - "file_downloader (18 violations)"
          - "file_uploader (16 violations)"
          - "animations_manager (32 violations)"
        remediation_pattern: "Result<T, IoError>"
        
      category_1_3:
        name: "State Management"
        crates:
          - "connection_state_manager (35 violations)"
          - "dialog_filter_manager (141 violations)"
          - "dialog_participant_manager (66 violations)"
        remediation_pattern: "Result<T, StateError>"
        
  batch_2:
    name: "Type Crate Serialization"
    scope: "unwrap() in serialization tests and type crates"
    estimated_violations: 1200
    priority: "HIGH"
    duration: "1-2 weeks"
    
    subcategories:
      category_2_1:
        name: "ID Type Serialization"
        crates:
          - "user_id, chat_id, message_id (types)"
          - "dialog_id, folder_id, story_id"
        remediation_pattern: "Add #[expect(clippy::unwrap_used)] to test functions"
        
      category_2_2:
        name: "Struct Serialization"
        crates:
          - "business_chat_link (4 violations)"
          - "new_password_state (2 violations)"
          - "notification_object_id (7 violations)"
        remediation_pattern: "Create test helper: fn test_serde<T>(value: &T) -> Result<(), SerdeError>"
        
  batch_3:
    name: "Safe Unwrap Assertions"
    scope: "Mathematically safe unwrap() calls that should never fail"
    estimated_violations: 600
    priority: "MEDIUM"
    duration: "1 week"
    
    subcategories:
      category_3_1:
        name: "Type Conversion Assertions"
        examples:
          - "String::from_utf8(vec).unwrap() where vec is known UTF-8"
          - "slice.try_into().unwrap() for fixed-size arrays"
        remediation_pattern: "Create safe_unwrap!() macro with documentation"
        
      category_3_2:
        name: "Actor Lifecycle Guarantees"
        examples:
          - "Arc::new(RwLock::new(state)).unwrap() - Arc allocation never fails"
          - "Mutex::new(data).unwrap() - Mutex creation never fails"
        remediation_pattern: "Add #[allow(clippy::unwrap_used)] with safety justification comment"

error_handling_patterns:
  result_type:
    description: "Standard Result propagation pattern"
    before: |
      fn process_data(input: &str) -> MyData {
          let parsed = serde_json::from_str(input).unwrap();
          MyData::new(parsed)
      }
    after: |
      fn process_data(input: &str) -> Result<MyData, SerializationError> {
          let parsed: InputData = serde_json::from_str(input)?;
          Ok(MyData::new(parsed))
      }
    
  option_handling:
    description: "Option instead of unwrap for non-guaranteed values"
    before: |
      fn get_user_name(users: &HashMap<UserId, User>, id: UserId) -> String {
          users.get(&id).unwrap().name.clone()
      }
    after: |
      fn get_user_name(users: &HashMap<UserId, User>, id: UserId) -> Option<String> {
          users.get(&id).map(|user| user.name.clone())
      }
    
  custom_macro:
    description: "Macro for safe unwrap with documentation"
    implementation: |
      /// Unwraps a Result/Option that is guaranteed to be Some/Ok
      /// 
      /// # Safety
      /// This macro should only be used when the invariant can be proven:
      /// - Type conversions that are guaranteed by construction
      /// - Algorithm guarantees that maintain the invariant
      /// - External library contracts that ensure success
      /// 
      /// # Examples
      /// ```
      /// // Safe: We know this is valid UTF-8 by construction
      /// let s = safe_unwrap!(String::from_utf8(vec));
      /// 
      /// // Safe: Fixed-size array from slice we control
      /// let arr: [u8; 32] = safe_unwrap!(slice.try_into());
      /// ```
      macro_rules! safe_unwrap {
          ($expr:expr) => {
              match $expr {
                  Ok(val) => val,
                  Err(_) => {
                      // Log the error for debugging
                      tracing::error!(
                          "safe_unwrap failed at {}:{}: {:?}",
                          file!(),
                          line!(),
                          stringify!($expr)
                      );
                      // In debug builds, panic with context
                      if cfg!(debug_assertions) {
                          panic!(
                              "safe_unwrap invariant violated: {} at {}:{}",
                              stringify!($expr),
                              file!(),
                              line!()
                          );
                      } else {
                          // In release, use unreachable_unchecked for performance
                          // SAFETY: The caller guarantees this is unreachable
                          unsafe { std::hint::unreachable_unchecked() }
                      }
                  }
              }
          };
      }
    
  test_expect:
    description: "Allow unwrap in tests with explicit marker"
    implementation: |
      #[cfg(test)]
      mod tests {
          #![expect(clippy::unwrap_used)]
          
          #[test]
          fn test_serialization() {
              let value = MyType::new();
              let json = serde_json::to_string(&value).unwrap();
              // ... test logic
          }
      }

testing_strategy:
  unit_tests:
    goal: "Maintain existing test coverage"
    approach: "Convert unwrap() to proper Result/Option assertions"
    before: |
      #[test]
      fn test_foo() {
          let result = foo().unwrap();
          assert_eq!(result.value, 42);
      }
    after: |
      #[test]
      fn test_foo() {
          #![expect(clippy::unwrap_used)]
          let result = foo().unwrap();
          assert_eq!(result.value, 42);
      }
      
  integration_tests:
    goal: "Test error paths, not just success paths"
    approach: "Add tests for error conditions"
    new_tests:
      - "Test serde_json::from_str with invalid JSON returns error"
      - "Test File::open with non-existent file returns error"
      - "Test HashMap::get with missing key returns None"
      
  regression_tests:
    goal: "Ensure no behavior changes during remediation"
    approach: "Snapshot testing for error messages"
    tool: "insta or similar crate for snapshot testing"

dependencies:
  internal:
    - name: "rustgram-types"
      reason: "Core error types"
    - name: "rustgram-log"
      reason: "Error logging in safe_unwrap! macro"
    - name: "All manager crates"
      reason: "Error type propagation"
      
  external:
    - name: "thiserror"
      version: "1.0"
      reason: "Error derive macros"
      usage: "Define custom error types for each crate"
    - name: "anyhow"
      version: "1.0"  
      reason: "Context for error conversion in application code"
      usage: "Use .context() for error propagation in main()"
    - name: "tracing"
      version: "0.1"
      reason: "Structured error logging"
      usage: "Log errors in safe_unwrap! macro"

acceptance_criteria:
  compilation:
    - criterion: "cargo build --workspace succeeds"
    - criterion: "cargo clippy --workspace passes with 0 warnings"
    - criterion: "No unwrap_used or expect_used lints in production code"
    
  code_quality:
    - criterion: "100% of unwrap() in production code replaced or documented"
    - criterion: "Test code uses #![expect(clippy::unwrap_used)] module attribute"
    - criterion: "safe_unwrap!() macro used for < 50 truly safe unwrap cases"
    - criterion: "All error paths tested"
    
  documentation:
    - criterion: "Each crate has error module with Error type"
    - criterion: "safe_unwrap!() usage documented with safety proof"
    - criterion: "Error types implement Display, Error, StdError traits"
    
  performance:
    - criterion: "No performance regression > 5% in hot paths"
    - criterion: "Error allocation minimized (Box::new only when needed)"
    - criterion: "safe_unwrap!() uses unreachable_unchecked() in release"

risks:
  breaking_changes:
    risk_level: "MEDIUM"
    description: "Changing function signatures from T to Result<T, E> breaks existing callers"
    mitigation: |
      1. Start with internal functions (leaf nodes)
      2. Update call sites incrementally
      3. Use batch approach to minimize churn
      4. Run full test suite after each batch
      
  test_explosion:
    risk_level: "LOW"
    description: "Need to add many error path tests"
    mitigation: |
      1. Use property-based testing (proptest) for error cases
      2. Focus on critical error paths first
      3. Accept 80% test coverage for error paths
      4. Use snapshot testing for error messages
      
  safe_unwrap_abuse:
    risk_level: "MEDIUM"
    description: "Developers may overuse safe_unwrap! macro"
    mitigation: |
      1. Require code review for all safe_unwrap! usage
      2. Document safety invariant in comment
      3. Track safe_unwrap! count (target: < 50 occurrences)
      4. Regular clippy audit
      
  performance_regression:
    risk_level: "LOW"
    description: "Error handling overhead may impact performance"
    mitigation: |
      1. Benchmark critical paths before/after
      2. Use ? operator for zero-cost error propagation
      3. Keep error types small (Copy/Clone where possible)
      4. Profile after each batch

next_steps:
  phase_3:
    name: "Verification Gate"
    activities:
      - "Review spec.yaml with stakeholders"
      - "Validate risk register"
      - "Approve batch execution strategy"
      - "Set up quality metrics dashboard"
      
  phase_4:
    name: "Batch 1 Execution"
    activities:
      - "Start with critical path managers"
      - "Update error types per crate"
      - "Remediate dialog_manager (96 violations)"
      - "Run full test suite after each crate"
      
  phase_5:
    name: "Batch 2 Execution"
    activities:
      - "Focus on serialization tests"
      - "Add #![expect] to test modules"
      - "Create test helper functions"
      - "Validate all serialization tests pass"
      
  phase_6:
    name: "Batch 3 Execution"
    activities:
      - "Implement safe_unwrap! macro"
      - "Document each usage with safety proof"
      - "Audit and approve each safe_unwrap"
      - "Final clippy check"

appendices:
  unwrap_categories:
    test_code:
      count: 1540
      percentage: 40
      examples:
        - "serde_json tests"
        - "bincode tests"  
        - "comparison tests"
        
    serialization:
      count: 962
      percentage: 25
      examples:
        - "serde_json::to_string().unwrap()"
        - "serde_json::from_str().unwrap()"
        - "bincode::serialize().unwrap()"
        
    actor_init:
      count: 577
      percentage: 15
      examples:
        - "Arc::new().unwrap()"
        - "RwLock::new().unwrap()"
        - "String::from_utf8().unwrap()"
        
    file_ops:
      count: 385
      percentage: 10
      examples:
        - "File::open().unwrap()"
        - "fs::read().unwrap()"
        - "fs::write().unwrap()"
        
    crypto:
      count: 192
      percentage: 5
      examples:
        - "key.try_into().unwrap()"
        - "Vec::from_hex().unwrap()"
        
    indexing:
      count: 192
      percentage: 5
      examples:
        - "vec[idx].unwrap()"
        - "map[&key].unwrap()"
        
  priority_order:
    top_10_crates:
      - crate: "call_manager"
        violations: 115
        category: "Critical Path"
        batch: 1
        
      - crate: "group_call_manager"
        violations: 105
        category: "Critical Path"
        batch: 1
        
      - crate: "chat_manager"
        violations: 109
        category: "Critical Path"
        batch: 1
        
      - crate: "dialog_filter_manager"
        violations: 141
        category: "State Management"
        batch: 1
        
      - crate: "dialog_manager"
        violations: 96
        category: "Critical Path"
        batch: 1
        
      - crate: "download_manager"
        violations: 64
        category: "File Operations"
        batch: 1
        
      - crate: "callback_queries_manager"
        violations: 47
        category: "State Management"
        batch: 1
        
      - crate: "animations_manager"
        violations: 32
        category: "File Operations"
        batch: 1
        
      - crate: "inline_message_manager"
        violations: 40
        category: "State Management"
        batch: 1
        
      - crate: "dialog_participant_manager"
        violations: 66
        category: "State Management"
        batch: 1

validation:
  spec_completeness:
    requirements_covered: true
    dependencies_identified: true
    risks_assessed: true
    acceptance_criteria_defined: true
    
  plan_consistency:
    matches_phase1_findings: true
    batch_strategy_validated: true
    timeline_realistic: true
    resource_requirements_clear: true
