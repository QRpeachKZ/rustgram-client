spec:
  module: bot_recommendation_manager
  version: 0.1.0
  created: 2026-01-14T13:00:00Z
  updated: 2026-01-14T13:00:00Z
  language: rust
  complexity: medium
  estimated_loc: 450
  is_state_machine: false

plan:
  - item: Comprehend and Analyze TDLib Implementation
  - item: Implement RecommendedBots Internal Type
  - item: Implement BotRecommendationManager Structure
  - item: Implement Bot Recommendation Caching
  - item: Implement Database Key Generation and Persistence
  - item: Implement Query Management (Queuing and Deduplication)
  - item: Write Comprehensive Tests and Documentation
  - item: Review and Verify Module Compliance

success_criteria:
  code_quality:
    max_clippy_warnings: 0
    production_unwrap_calls: 0
    max_cyclomatic_complexity: 15
  
  test_coverage:
    min_tests: 50
    min_line_coverage: 80
  
  documentation:
    public_api_docs_percent: 100
    examples_required: true
  
  tdlib_alignment:
    api_compatibility: strict

dependency_matrix:
  - type: UserId
    source: rustgram-types
    constructor: new(i64) -> Result<UserId, TypeError>
    location: types/src/ids.rs:40-51
    verified: true
  
  - type: Result
    source: std::result
    constructor: Ok(), Err()
    location: std
    verified: true

  - type: Promise
    source: NEW TYPE REQUIRED (async equivalent)
    constructor: TBD
    location: Use futures::channel::oneshot
    verified: false

  - type: FlatHashMap
    source: std::collections
    constructor: HashMap::new()
    location: std::collections::HashMap
    verified: true

risk_register:
  - id: R1
    type: MISSING_DEPENDENCY
    dependency: Promise type (async equivalent)
    mitigation: Use futures::channel::oneshot for async communication
    impact: MEDIUM
    status: MITIGATED
  
  - id: R2
    type: MISSING_DEPENDENCY
    dependency: Actor framework
    mitigation: Use tokio::sync::mpsc for message passing
    impact: MEDIUM
    status: MITIGATED
  
  - id: R3
    type: SERIALIZATION
    dependency: RecommendedBots persistence
    mitigation: Implement serde Serialize/Deserialize for cache
    impact: LOW
    status: MITIGATED
  
  - id: R4
    type: THREAD_SAFETY
    dependency: Concurrent query access
    mitigation: Use Arc<RwLock<HashMap>> for query storage
    impact: MEDIUM
    status: MITIGATED

reference:
  tdlib_header: references/td/td/telegram/BotRecommendationManager.h
  tdlib_impl: references/td/td/telegram/BotRecommendationManager.cpp
  user_id_header: references/td/td/telegram/UserId.h

type_definitions:
  RecommendedBots:
    docs: |
      Internal structure storing cached bot recommendations.
      
      Contains:
      - total_count: Total number of recommended bots
      - bot_user_ids: Vector of recommended bot user IDs
      - next_reload_time: Timestamp for cache expiration
    fields:
      - name: total_count
        type: i32
        docs: Total number of recommended bots
      - name: bot_user_ids
        type: Vec<UserId>
        docs: List of recommended bot user IDs
      - name: next_reload_time
        type: f64
        docs: Unix timestamp for cache expiration
    methods:
      - is_empty() -> bool
      - needs_reload() -> bool
      - update_next_reload_time()

api_methods:
  - name: get_bot_recommendations
    signature: |
      get_bot_recommendations(
          bot_user_id: UserId,
          return_local: bool,
      ) -> impl Future<Output = Result<Users, Error>>
    docs: |
      Get bot recommendations for the specified bot.
      
      If return_local is true, returns cached data even if expired.
      Otherwise, fetches fresh data from server if cache is expired.
    params:
      - name: bot_user_id
        type: UserId
        docs: The bot to get recommendations for
      - name: return_local
        type: bool
        docs: Whether to return cached data without revalidation
    returns: Future yielding Users with recommended bot user IDs
    thread_safety: Thread-safe with concurrent query deduplication

  - name: open_bot_recommended_bot
    signature: |
      open_bot_recommended_bot(
          bot_user_id: UserId,
          opened_bot_user_id: UserId,
      ) -> impl Future<Output = Result<(), Error>>
    docs: |
      Track that a user opened a recommended bot.
      
      This is used for analytics and may affect future recommendations.
    params:
      - name: bot_user_id
        type: UserId
        docs: The original bot that made the recommendation
      - name: opened_bot_user_id
        type: UserId
        docs: The bot that was opened
    returns: Future completing when tracking is recorded
    thread_safety: Thread-safe

private_methods:
  - is_suitable_recommended_bot(bot_user_id: UserId) -> bool
  - are_suitable_recommended_bots(recommended_bots: &RecommendedBots) -> bool
  - get_bot_recommendations_database_key(bot_user_id: UserId) -> String
  - load_bot_recommendations_from_database(key: String) -> Option<RecommendedBots>
  - save_bot_recommendations_to_database(key: String, bots: &RecommendedBots)
  - reload_bot_recommendations(bot_user_id: UserId)

constants:
  - name: BOT_RECOMMENDATIONS_CACHE_TIME
    value: 86400
    docs: Cache time in seconds (24 hours)

test_plan:
  unit_tests:
    - test_recommended_bots_new_empty
    - test_recommended_bots_new_with_data
    - test_recommended_bots_is_empty
    - test_recommended_bots_needs_reload_true
    - test_recommended_bots_needs_reload_false
    - test_recommended_bots_update_next_reload_time
    - test_manager_new
    - test_manager_get_bot_recommendations_local
    - test_manager_get_bot_recommendations_fresh
    - test_manager_open_bot_recommended_bot
    - test_manager_concurrent_query_deduplication
    - test_manager_cache_expiration
    - test_database_key_generation
    - test_is_suitable_recommended_bot_valid
    - test_is_suitable_recommended_bot_invalid

  edge_cases:
    - Empty bot recommendations list
    - Cache expiration edge cases
    - Concurrent duplicate queries
    - Database read/write failures
    - Invalid user IDs

tdlib_deviations: []
