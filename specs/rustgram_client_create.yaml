# Specification: RustgramClient::create() Implementation
## Task: rustgram-client-ufz.2

```yaml
task: rustgram_client_create
title: Implement TDLib-compatible RustgramClient::create() method
priority: P1
complexity: low
estimated_hours: 4
assigned_to: developer

# Context
# 
# The paper_plane_adapter crate needs a TDLib-compatible create() method that:
# 1. Matches tdlib::create_client() semantics (returns ClientId, not Arc<RustgramClient>)
# 2. Internally manages ClientActor instances per client
# 3. Uses a global registry for multi-client support
#
# Current state:
# - RustgramClient exists in lib.rs but returns Arc<Self>
# - ClientRegistry exists in client.rs with full registration logic
# - Two ClientConfig types exist (need to resolve)
# - ClientActor has new_with_defaults() constructor

# Design Decisions
decisions:
  client_config_resolution:
    decision: "Use TDLib-style ClientConfig from client.rs"
    reasoning: |
      - The spec defines TDLib-compatible API (api_id, api_hash, database_path, etc.)
      - Manager config is internal implementation detail
      - Managers should be created internally by create() or injected via separate mechanism
    impact: "lib.rs ClientConfig becomes internal use only"
    
  method_signature:
    decision: "pub async fn create(config: ClientConfig) -> Result<ClientId, AdapterError>"
    reasoning: |
      - Matches TDLib's td_create_client_id() semantics
      - Paper plane reference (client_manager.rs:77) shows tdlib::create_client() returning ClientId
      - Async needed for ClientActor initialization and registration
    signature: "pub async fn create(config: ClientConfig) -> Result<ClientId, AdapterError>"
    
  return_type:
    decision: "Result<ClientId, AdapterError> only (not Arc<RustgramClient>)"
    reasoning: |
      - TDLib API returns client ID, not client instance
      - ClientRegistry stores Arc<ClientActor> internally
      - Subsequent calls use client_id to look up actor
      - Spec explicitly states this signature
    impact: "Breaking change from current Arc<Self> return"
    
  registry_management:
    decision: "Global singleton registry via once_cell or std::sync::OnceLock"
    reasoning: |
      - TDLib maintains global client registry internally
      - Multiple GUI instances may share the same adapter
      - Thread-safe access needed for glib main thread
      - Atomic reference for global access
    implementation: "static REGISTRY: OnceLock<Arc<ClientRegistry>>"
    
  actor_lifecycle:
    decision: "ClientRegistry owns Arc<ClientActor> instances"
    reasoning: |
      - Registry already has register/unregister in place
      - Actor cleanup via destroy(client_id) calls registry.unregister()
      - Arc ensures actor lives while registered
    ownership: "ClientRegistry owns, create() registers, destroy() unregisters"

# Implementation Specification

api:
  create_method:
    signature: "pub async fn create(config: ClientConfig) -> Result<ClientId, AdapterError>"
    location: "crates/paper_plane_adapter/src/lib.rs (impl RustgramClient)"
    documentation: |
      Creates a new TDLib-compatible client instance.
      
      This method matches TDLib's td_create_client_id() semantics:
      - Creates a new ClientActor with the provided configuration
      - Registers the actor in the global client registry
      - Returns a unique ClientId for subsequent operations
      
      # Arguments
      
      * `config` - TDLib-style client configuration (api_id, api_hash, database_path, etc.)
      
      # Returns
      
      * `ClientId` - Unique client identifier compatible with TDLib
      
      # Errors
      
      Returns `AdapterError` if:
      - ClientActor initialization fails
      - Registration fails (should not happen in practice)
      
      # Example
      
      ```no_run
      use paper_plane_adapter::{RustgramClient, ClientConfig};
      
      let config = ClientConfig {
          api_id: 12345,
          api_hash: "abcdef".to_string(),
          database_path: "/tmp/tdlib".to_string(),
          files_directory: "/tmp/tdlib_files".to_string(),
          use_test_dc: false,
          default_dc_id: 2,
      };
      
      let client_id = RustgramClient::create(config).await?;
      println!("Created client: {}", client_id.get());
      ```
      
      # TDLib Equivalent
      
      This method is equivalent to:
      ```c
      int32_t td_create_client_id();
      ```
      
      But with initialization parameters passed as config instead of setTdlibParameters.
    
    steps:
      - name: "Validate configuration"
        description: "Check api_id > 0, api_hash not empty, paths valid"
        error: "AdapterError::InvalidValue"
        
      - name: "Get global registry"
        description: "Access or create global ClientRegistry singleton"
        implementation: "REGISTRY.get_or_init(|| Arc::new(ClientRegistry::new()))"
        
      - name: "Create ClientActor"
        description: "Initialize ClientActor with ClientActorOptions"
        implementation: |
          let options = ClientActorOptions::new()
              .with_default_dc_id(config.default_dc_id);
          let actor = Arc::new(ClientActor::new(options));
        
      - name: "Register actor"
        description: "Register actor in global registry"
        implementation: "let client_id = registry.register(actor).await"
        
      - name: "Return client_id"
        description: "Return the assigned ClientId"

# Module: Global Registry
global_registry:
  location: "crates/paper_plane_adapter/src/lib.rs"
  implementation: |
    use std::sync::OnceLock;
    
    /// Global client registry singleton.
    /// 
    /// TDLib maintains a global registry of client instances.
    /// This matches that pattern for TDLib compatibility.
    static GLOBAL_REGISTRY: OnceLock<Arc<ClientRegistry>> = OnceLock::new();
    
    /// Gets or initializes the global client registry.
    fn global_registry() -> &'static Arc<ClientRegistry> {
        GLOBAL_REGISTRY.get_or_init(|| {
            Arc::new(ClientRegistry::new())
        })
    }
  thread_safety: "OnceLock provides thread-safe one-time initialization"
  access_pattern: "Internal only - not exposed in public API"

# Module: ClientConfig Export
client_config_export:
  action: "Re-export client::ClientConfig as public API"
  location: "crates/paper_plane_adapter/src/lib.rs"
  implementation: |
    // Re-export TDLib-compatible config
    pub use crate::client::{ClientId, ClientConfig};
  reasoning: |
    - client.rs ClientConfig has TDLib-compatible fields
    - Should be public API for users
    - lib.rs ClientConfig becomes internal (rename to InternalClientConfig)

# Module: destroy Method
destroy_method:
  signature: "pub async fn destroy(client_id: ClientId) -> Result<(), AdapterError>"
  location: "crates/paper_plane_adapter/src/lib.rs"
  documentation: |
    Destroys a client instance and releases its resources.
    
    Matches TDLib's td_destroy_client_id() semantics.
    
    # Arguments
    
    * `client_id` - The client ID to destroy
    
    # Returns
    
    * `Ok(())` if client was destroyed successfully
    
    # Errors
    
    Returns `AdapterError::InvalidClientId` if the client doesn't exist.
  steps:
    - name: "Get global registry"
    - name: "Unregister client"
      implementation: "registry.unregister(client_id).await"
    - name: "Return result"

# Error Handling
error_handling:
  create_errors:
    - variant: "InvalidValue"
      when: "api_id <= 0, api_hash empty, or paths invalid"
      message: "Invalid {field}: {reason}"
      code: 400
      
    - variant: "Manager"
      when: "ClientActor creation fails"
      message: "Failed to create client actor: {reason}"
      code: 500
      
  destroy_errors:
    - variant: "InvalidClientId"
      when: "Client ID not found in registry"
      message: "Client {id} does not exist"
      code: 400

# Testing Strategy
testing:
  unit_tests:
    - target: "RustgramClient::create()"
      cases:
        - name: "create_returns_valid_client_id"
          verify: "Returned ClientId.is_valid() == true"
          
        - name: "create_increments_registry_count"
          verify: "Registry count increases after create"
          
        - name: "create_with_invalid_api_id"
          verify: "Returns InvalidValue error"
          
        - name: "create_generates_unique_ids"
          verify: "Multiple creates return different IDs"
          
    - target: "RustgramClient::destroy()"
      cases:
        - name: "destroy_decreases_registry_count"
          verify: "Registry count decreases after destroy"
          
        - name: "destroy_invalid_client_id"
          verify: "Returns InvalidClientId error"
          
        - name: "destroy_allows_reuse_id"
          verify: "After destroy, new create may reuse ID"
          
    - target: "Global registry"
      cases:
        - name: "global_registry_is_singleton"
          verify: "Multiple calls return same Arc reference"
          
        - name: "global_registry_thread_safe"
          verify: "Concurrent creates from multiple threads"

  integration_tests:
    - name: "create_destroy_cycle"
      scenario: |
        1. Create client with valid config
        2. Verify registration in registry
        3. Destroy client
        4. Verify removal from registry
        5. Create new client
        6. Verify new client ID

# Dependencies
dependencies:
  internal:
    - crate: "client_actor"
      items: ["ClientActor", "ClientActorOptions"]
      reason: "Core client actor instance per client"
      
    - crate: "paper_plane_adapter::client"
      items: ["ClientRegistry", "ClientId", "ClientConfig"]
      reason: "Registry and type definitions"
      
  external:
    - crate: "std::sync::OnceLock"
      reason: "Global singleton registry (Rust 1.70+)"
      
    - crate: "std::sync::Arc"
      reason: "Shared registry reference"

# Success Criteria
acceptance_criteria:
  - function: "RustgramClient::create() exists with exact signature"
  - function: "Returns TDLib-compatible ClientId (i32 wrapper)"
  - function: "Registers ClientActor in global registry"
  - function: "Validates config before creation"
  - function: "RustgramClient::destroy() removes from registry"
  - coverage: "100% coverage for create/destroy paths"
  - tests: "Minimum 8 new unit tests, 2 integration tests"
  - compatibility: "Matches tdlib::create_client() semantics"

# Files Modified
files_modified:
  - path: "crates/paper_plane_adapter/src/lib.rs"
    changes:
      - add: "static GLOBAL_REGISTRY: OnceLock<Arc<ClientRegistry>>"
      - add: "pub async fn create(config: ClientConfig) -> Result<ClientId, AdapterError>"
      - add: "pub async fn destroy(client_id: ClientId) -> Result<(), AdapterError>"
      - add: "fn global_registry() -> &'static Arc<ClientRegistry>"
      - add: "pub use crate::client::{ClientId, ClientConfig}"
      - modify: "Rename existing ClientConfig to InternalClientConfig"
      
  - path: "crates/paper_plane_adapter/src/client.rs"
    changes:
      - add: "pub visibility to ClientConfig (if not already)"
      - add: "pub visibility to ClientId (if not already)"

# Backward Compatibility
backward_compatibility:
  breaking_changes:
    - item: "RustgramClient::new() and with_config() return Arc<Self>"
      mitigation: "Keep for internal use, deprecate for external users"
      migration: "Users should switch to RustgramClient::create()"
      
    - item: "ClientConfig type in lib.rs"
      mitigation: "Rename to InternalClientConfig"
      migration: "External users should use client::ClientConfig"

# Documentation Requirements
documentation:
  public_api_docs:
    - "RustgramClient::create() with full example"
    - "RustgramClient::destroy() with error handling"
    - "ClientConfig struct with field descriptions"
    - "ClientId type with TDLib compatibility notes"
    
  internal_docs:
    - "Global registry pattern explanation"
    - "Thread safety guarantees"
    - "Actor lifecycle management"

# Phase 2.5 Verification Gate
verification_gate:
  before_implementation:
    - question: "Do we need a separate ClientConfig for manager injection?"
      resolution: "No - managers are created internally or injected via separate factory"
    - question: "Should create() be async?"
      resolution: "Yes - ClientActor initialization and registry registration are async"
    - question: "What happens to existing new() method?"
      resolution: "Keep for internal use, deprecate in public API"
      
  after_implementation:
    - check: "All tests pass"
    - check: "cargo clippy -- -D warnings passes"
    - check: "cargo fmt -- --check passes"
    - check: "cargo doc --no-deps builds without warnings"
    - check: "Coverage meets 100% target for new code"
