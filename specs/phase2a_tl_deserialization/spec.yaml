# Technical Specification: Phase 2A - Core TL Deserialization
# Epic: rustgram-client-29c
# Version: 1.0
# Date: 2026-01-21
# Status: Draft

---

## 1. Overview

### 1.1 Purpose

Implement manual TL (Type Language) binary deserialization for core Telegram types, enabling proper parsing of network responses from MTProto servers.

### 1.2 Scope

**New Crate:** `crates/tl_core/`

**Types to Implement:**
- Photo types (Photo, PhotoSize variants, UserProfilePhoto)
- Peer types (Peer, InputPeer variants)
- Notification settings (PeerNotifySettings, InputPeerNotifySettings)
- ChatFull (20+ optional fields with complex flag handling)
- UserFull (15+ fields with nested types)
- Supporting types (BotInfo, ChatParticipants, ChannelParticipants)

### 1.3 Existing Infrastructure

**Dependencies:**
- `rustgram-types` - TlHelper, Bytes wrapper, TlDeserialize trait
- `rustgram-types/src/tl.rs` - TL serialization traits (377 lines)
- `rustgram-types/src/auth_responses.rs` - Example flag handling pattern

**Pattern Reference:**
- Manual `impl TlDeserialize` (not derive macros)
- Flag-based optional fields using `Option<T>`
- Constructor ID matching via `TlHelper::read_constructor_id()`

---

## 2. Module Structure

### 2.1 Crate Layout

```
crates/tl_core/
├── Cargo.toml                    # Dependencies: bytes, thiserror, serde
├── README.md                     # Documentation and examples
├── src/
│   ├── lib.rs                    # Public API exports (100 LOC)
│   ├── error.rs                  # TlError enum (200 LOC)
│   ├── flags.rs                  # FlagReader utility (150 LOC)
│   ├── photo.rs                  # Photo types (600 LOC)
│   ├── peer.rs                   # Peer types (400 LOC)
│   ├── notify.rs                 # Notification settings (300 LOC)
│   ├── chat_full.rs              # ChatFull + participants (1200 LOC)
│   ├── user_full.rs              # UserFull + BotInfo (500 LOC)
│   └── utils.rs                  # Vector deserialization helpers (100 LOC)
└── tests/
    ├── golden/                   # TDLib-captured binary test vectors
    │   ├── photo.bin
    │   ├── photo_empty.bin
    │   ├── chat_full.bin
    │   ├── chat_full_minimal.bin
    │   ├── user_full.bin
    │   ├── channel_participants.bin
    │   └── ...
    ├── constructor_ids.rs        # Constructor ID verification tests
    ├── golden_tests.rs           # Golden test runner
    └── integration.rs            # Integration tests
```

### 2.2 Public API

```rust
// tl_core/src/lib.rs

//! Core TL (Type Language) deserialization for Telegram MTProto.
//!
//! This crate provides manual implementations of TL binary format
//! deserialization for core Telegram types used by the rustgram-client.
//!
//! # Example
//!
//! ```rust
//! use rustgram_tl_core::{Photo, PeerNotifySettings};
//! use rustgram_types::Bytes;
//!
//! let mut buf = Bytes::new(raw_response_bytes);
//! let photo = Photo::deserialize_tl(&mut buf)?;
//! # Ok::<(), Box<dyn std::error::Error>>(())
//! ```

pub mod error;
pub mod flags;
pub mod photo;
pub mod peer;
pub mod notify;
pub mod chat_full;
pub mod user_full;

// Re-exports for convenience
pub use error::TlError;
pub use flags::FlagReader;
pub use photo::{Photo, PhotoSize, UserProfilePhoto};
pub use peer::{Peer, InputPeer};
pub use notify::{PeerNotifySettings, InputPeerNotifySettings};
pub use chat_full::{ChatFull, ChatParticipants, ChannelParticipant};
pub use user_full::{UserFull, BotInfo};
```

---

## 3. Data Structures

### 3.1 Photo Types

**Location:** `tl_core/src/photo.rs`

**TL Schema:**
```tl
photoEmpty#2331b22d id:long = Photo;
photo#fb197a65 flags:# has_stickers:flags.0?true id:long access_hash:long 
    file_reference:bytes date:int sizes:Vector<PhotoSize> 
    video_sizes:flags.1?Vector<VideoSize> dc_id:int = Photo;
```

**Rust Definition:**
```rust
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Photo {
    Empty { id: i64 },
    Photo {
        has_stickers: bool,
        id: i64,
        access_hash: i64,
        file_reference: Vec<u8>,
        date: i32,
        sizes: Vec<PhotoSize>,
        video_sizes: Option<Vec<VideoSize>>,
        dc_id: i32,
    },
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PhotoSize {
    Empty { type_: String },
    Size { type_: String, w: i32, h: i32, size: i32 },
    Cached { type_: String, w: i32, h: i32, bytes: Vec<u8> },
    Stripped { type_: String, bytes: Vec<u8> },
    Progressive { type_: String, w: i32, h: i32, sizes: Vec<i32> },
    Path { type_: String, bytes: Vec<u8> },
}
```

### 3.2 Peer Types

**Location:** `tl_core/src/peer.rs`

**TL Schema:**
```tl
peerUser#59511722 user_id:long = Peer;
peerChat#36c6019a chat_id:long = Peer;
peerChannel#a2a5371e channel_id:long = Peer;
```

**Rust Definition:**
```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Peer {
    User { user_id: i64 },
    Chat { chat_id: i64 },
    Channel { channel_id: i64 },
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum InputPeer {
    Empty,
    Self,
    Chat { chat_id: i64 },
    User { user_id: i64, access_hash: i64 },
    Channel { channel_id: i64, access_hash: i64 },
    UserFromMessage { peer: Box<InputPeer>, msg_id: i32, user_id: i64 },
    ChannelFromMessage { peer: Box<InputPeer>, msg_id: i32, channel_id: i64 },
}
```

### 3.3 Notification Settings

**Location:** `tl_core/src/notify.rs`

**TL Schema:**
```tl
peerNotifySettings#99622c0c flags:# show_previews:flags.0?Bool 
    silent:flags.1?Bool mute_until:flags.2?int 
    ios_sound:flags.3?NotificationSound android_sound:flags.4?NotificationSound 
    other_sound:flags.5?NotificationSound stories_muted:flags.6?Bool 
    stories_hide_sender:flags.7?Bool stories_ios_sound:flags.8?NotificationSound 
    stories_android_sound:flags.9?NotificationSound 
    stories_other_sound:flags.10?NotificationSound = PeerNotifySettings;
```

**Rust Definition:**
```rust
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct PeerNotifySettings {
    pub show_previews: Option<bool>,
    pub silent: Option<bool>,
    pub mute_until: Option<i32>,
    pub ios_sound: Option<NotificationSound>,
    pub android_sound: Option<NotificationSound>,
    pub other_sound: Option<NotificationSound>,
    pub stories_muted: Option<bool>,
    pub stories_hide_sender: Option<bool>,
    pub stories_ios_sound: Option<NotificationSound>,
    pub stories_android_sound: Option<NotificationSound>,
    pub stories_other_sound: Option<NotificationSound>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum NotificationSound {
    None,
    Default,
    Local { path: String },
    Ringtone { id: i64 },
}
```

### 3.4 ChatFull

**Location:** `tl_core/src/chat_full.rs`

**TL Schema:**
```tl
chatFull#2633421b flags:# can_set_username:flags.7?true 
    has_scheduled:flags.8?true translations_disabled:flags.19?true 
    id:long about:string participants:ChatParticipants 
    chat_photo:flags.2?Photo notify_settings:PeerNotifySettings 
    exported_invite:flags.13?ExportedChatInvite 
    bot_info:flags.3?Vector<BotInfo> pinned_msg_id:flags.6?int 
    folder_id:flags.11?int call:flags.12?InputGroupCall 
    ttl_period:flags.14?int groupcall_default_join_as:flags.15?Peer 
    theme_emoticon:flags.16?string requests_pending:flags.17?int 
    recent_requesters:flags.17?Vector<long> 
    available_reactions:flags.18?ChatReactions reactions_limit:flags.20?int 
    = ChatFull;
```

**Rust Definition:**
```rust
#[derive(Debug, Clone, PartialEq)]
pub struct ChatFull {
    pub can_set_username: bool,
    pub has_scheduled: bool,
    pub translations_disabled: bool,
    pub id: i64,
    pub about: String,
    pub participants: ChatParticipants,
    pub chat_photo: Option<Photo>,
    pub notify_settings: PeerNotifySettings,
    pub exported_invite: Option<ExportedChatInvite>,
    pub bot_info: Option<Vec<BotInfo>>,
    pub pinned_msg_id: Option<i32>,
    pub folder_id: Option<i32>,
    pub call: Option<InputGroupCall>,
    pub ttl_period: Option<i32>,
    pub groupcall_default_join_as: Option<Peer>,
    pub theme_emoticon: Option<String>,
    pub requests_pending: Option<i32>,
    pub recent_requesters: Option<Vec<i64>>,
    pub available_reactions: Option<ChatReactions>,
    pub reactions_limit: Option<i32>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ChatParticipants {
    Chat(ChatParticipantsData),
    Forbidden(ChatParticipantsForbidden),
}

#[derive(Debug, Clone, PartialEq)]
pub struct ChatParticipantsData {
    pub chat_id: i64,
    pub participants: Vec<ChatParticipant>,
    pub version: i32,
}
```

### 3.5 UserFull

**Location:** `tl_core/src/user_full.rs`

**TL Schema:**
```tl
userFull#e24898fc flags:# blocked:flags.0?true phone_calls_available:flags.4?true 
    phone_calls_private:flags.5?true can_pin_message:flags.7?true 
    has_scheduled:flags.12?true video_calls_available:flags.13?true 
    id:long about:string settings:PeerSettings personal_photo:flags.2?Photo 
    profile_photo:Photo fallback_photo:flags.16?Photo 
    notify_settings:PeerNotifySettings bot_info:flags.3?BotInfo 
    pinned_msg_id:flags.6?int common_chat_count:int folder_id:flags.11?int 
    ttl_period:flags.14?int theme_emoticon:flags.15?string 
    private_forward_name:flags.17?string voice_messages_forbidden:flags.18?true 
    birthdays:flags.19?UserBirthdays business_work_hours:flags.21?BusinessWorkHours 
    personal_channel_id:flags.22?long personal_channel_message:flags.22?int 
    = UserFull;
```

**Rust Definition:**
```rust
#[derive(Debug, Clone, PartialEq)]
pub struct UserFull {
    pub blocked: bool,
    pub phone_calls_available: bool,
    pub phone_calls_private: bool,
    pub can_pin_message: bool,
    pub has_scheduled: bool,
    pub video_calls_available: bool,
    pub id: i64,
    pub about: String,
    pub settings: Option<PeerSettings>,
    pub personal_photo: Option<Photo>,
    pub profile_photo: Photo,
    pub fallback_photo: Option<Photo>,
    pub notify_settings: PeerNotifySettings,
    pub bot_info: Option<BotInfo>,
    pub pinned_msg_id: Option<i32>,
    pub common_chat_count: i32,
    pub folder_id: Option<i32>,
    pub ttl_period: Option<i32>,
    pub theme_emoticon: Option<String>,
    pub private_forward_name: Option<String>,
    pub voice_messages_forbidden: bool,
    pub birthdays: Option<UserBirthdays>,
    pub business_work_hours: Option<BusinessWorkHours>,
    pub personal_channel_id: Option<i64>,
    pub personal_channel_message: Option<i32>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct BotInfo {
    pub description: Option<String>,
    pub photo: Option<Photo>,
    pub animation: Option<Animation>,
    pub commands: Vec<BotCommand>,
    pub menu_button: Option<BotMenuButton>,
    // ... additional fields per TL schema
}
```

---

## 4. Flag Handling

### 4.1 FlagReader Utility

**Location:** `tl_core/src/flags.rs`

```rust
pub struct FlagReader {
    flags: u32,
}

impl FlagReader {
    pub fn new(flags: u32) -> Self {
        Self { flags }
    }
    
    /// Check if bit `n` is set (0-indexed)
    #[inline]
    pub fn has(&self, n: u32) -> bool {
        self.flags & (1 << n) != 0
    }
    
    /// Read optional field based on flag bit
    pub fn read_optional<T, F>(
        &self,
        bit: u32,
        reader: F,
    ) -> Result<Option<T>, TlError>
    where
        F: FnOnce() -> Result<T, TlError>,
    {
        if self.has(bit) {
            Some(reader()?).transpose()
        } else {
            Ok(None)
        }
    }
    
    /// Read bool flag directly
    #[inline]
    pub fn read_bool(&self, bit: u32) -> bool {
        self.has(bit)
    }
}
```

### 4.2 Flag Usage Pattern

```rust
impl TlDeserialize for Photo {
    fn deserialize_tl(buf: &mut Bytes) -> Result<Self, TlError> {
        let constructor = u32::from(TlHelper::read_constructor_id(buf)?);
        
        match constructor {
            0xfb197a65 => { // photo
                let flags = u32::from(TlHelper::read_i32(buf)?);
                let flag_reader = FlagReader::new(flags);
                
                let has_stickers = flag_reader.read_bool(0);
                let id = TlHelper::read_i64(buf)?;
                let access_hash = TlHelper::read_i64(buf)?;
                let file_reference = TlHelper::read_bytes(buf)?;
                let date = TlHelper::read_i32(buf)?;
                let sizes = deserialize_vector::<PhotoSize>(buf)?;
                let video_sizes = flag_reader.read_optional(1, || {
                    deserialize_vector::<VideoSize>(buf)
                })?;
                let dc_id = TlHelper::read_i32(buf)?;
                
                Ok(Self::Photo {
                    has_stickers,
                    id,
                    access_hash,
                    file_reference,
                    date,
                    sizes,
                    video_sizes,
                    dc_id,
                })
            }
            // ... other constructors
            _ => Err(TlError::UnknownConstructor {
                expected: vec![0x2331b22d, 0xfb197a65],
                found: constructor,
                context: "Photo".to_string(),
            }),
        }
    }
}
```

---

## 5. Error Handling

### 5.1 Error Types

**Location:** `tl_core/src/error.rs`

```rust
#[derive(Debug, thiserror::Error)]
pub enum TlError {
    #[error("Unknown constructor ID: 0x{found:08x}, expected one of: {expected:?}")]
    UnknownConstructor {
        expected: Vec<u32>,
        found: u32,
        context: String,
    },
    
    #[error("Unexpected EOF: requested {requested} bytes, {remaining} remaining for type '{type_name}'")]
    UnexpectedEof {
        requested: usize,
        remaining: usize,
        type_name: String,
    },
    
    #[error("Invalid UTF-8 string in field '{field_name}': {cause}")]
    InvalidUtf8 {
        field_name: String,
        #[source]
        cause: std::string::FromUtf8Error,
    },
    
    #[error("Vector deserialization failed: {0}")]
    VectorError(#[from] VectorError),
    
    #[error("Flag field error at bit {flag_index} ('{field_name}'): {cause}")]
    FlagFieldError {
        flag_index: u32,
        field_name: String,
        #[source]
        cause: Box<TlError>,
    },
    
    #[error("Validation failed for field '{field_name}': value={value}, reason={reason}")]
    ValidationFailed {
        field_name: String,
        value: String,
        reason: String,
    },
}

#[derive(Debug, thiserror::Error)]
pub enum VectorError {
    #[error("Vector size {size} exceeds maximum {max}")]
    TooLarge { size: usize, max: usize },
    
    #[error("Vector prefix invalid: {0}")]
    InvalidPrefix(u32),
}
```

---

## 6. Integration Points

### 6.1 user_manager Integration

**Before:**
```rust
// user_manager/src/network.rs
// TODO: Implement proper UserFull deserialization
let user_full = parse_user_full_placeholder(response.data)?;
```

**After:**
```rust
use rustgram_tl_core::UserFull;

let mut buf = Bytes::new(response.data);
let user_full = UserFull::deserialize_tl(&mut buf)
    .map_err(|e| UserManagerError::DeserializationError {
        field: "user_full".to_string(),
        cause: e.to_string(),
    })?;
```

### 6.2 dialog_manager Integration

**Before:**
```rust
// dialog_manager/src/tl_types.rs
// TODO: Implement proper TL deserialization from telegram_api.tl:132
```

**After:**
```rust
use rustgram_tl_core::{ChatFull, ChannelParticipants};

let mut buf = Bytes::new(response.data);
let chat_full = ChatFull::deserialize_tl(&mut buf)
    .map_err(|e| DialogError::DeserializationError(e.to_string()))?;
```

### 6.3 Dependencies

**tl_core/Cargo.toml:**
```toml
[package]
name = "rustgram-tl-core"
version = "0.1.0"
edition = "2021"

[dependencies]
rustgram-types = { path = "../types" }
bytes = "1.5"
thiserror = "1.0"
serde = { version = "1.0", features = ["derive"] }

[dev-dependencies]
criterion = "0.5"
proptest = "1.0"
hex = "0.4"
```

**user_manager/Cargo.toml (add):**
```toml
[dependencies]
rustgram-tl-core = { path = "../tl_core" }
```

**dialog_manager/Cargo.toml (add):**
```toml
[dependencies]
rustgram-tl-core = { path = "../tl_core" }
```

---

## 7. Testing Requirements

### 7.1 Unit Tests (200+ tests)

**photo.rs (40 tests):**
```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_photo_empty_deserialize() {
        let data = hex!("2331b22d 000000000000007e"); // photoEmpty with id=126
        let mut buf = Bytes::new(data.to_vec());
        let result = Photo::deserialize_tl(&mut buf).unwrap();
        assert_eq!(result, Photo::Empty { id: 126 });
    }
    
    #[test]
    fn test_photo_with_all_flags() {
        // has_stickers=true, video_sizes present
    }
    
    // ... 38 more tests
}
```

**chat_full.rs (60 tests):**
```rust
#[test]
fn test_chat_full_minimal() {
    // Only required fields
}

#[test]
fn test_chat_full_all_fields() {
    // All 20+ optional fields present
}

#[test]
fn test_chat_full_flag_bit_7() {
    // can_set_username flag
}

// ... 57 more tests
}
```

### 7.2 Golden Tests (10+ test files)

**tests/golden_tests.rs:**
```rust
#[test]
fn test_golden_photo() {
    let data = include_bytes!("golden/photo.bin");
    let mut buf = Bytes::new(data.to_vec());
    let result = Photo::deserialize_tl(&mut buf);
    assert!(result.is_ok(), "Failed: {:?}", result);
    
    let photo = result.unwrap();
    assert!(matches!(photo, Photo::Photo { .. }));
}

#[test]
fn test_golden_chat_full() {
    let data = include_bytes!("golden/chat_full.bin");
    let mut buf = Bytes::new(data.to_vec());
    let result = ChatFull::deserialize_tl(&mut buf);
    assert!(result.is_ok(), "Failed: {:?}", result);
}

// ... 8 more golden tests
}
```

### 7.3 Constructor ID Tests

**tests/constructor_ids.rs:**
```rust
#[test]
fn test_verify_photo_constructor_ids() {
    assert_eq!(Photo::Empty { id: 0 }.constructor_id(), 0x2331b22d);
    assert_eq!(Photo::Photo { /* fields */ }.constructor_id(), 0xfb197a65);
}

#[test]
fn test_verify_chat_full_constructor_id() {
    let chat_full = create_test_chat_full();
    assert_eq!(chat_full.constructor_id(), 0x2633421b);
}

#[test]
fn test_verify_all_constructor_ids() {
    // Auto-verify all implemented types
}
```

---

## 8. Constructor ID Reference

| Type | Constructor | Hex | TL Schema Line |
|------|-------------|-----|----------------|
| photoEmpty | 0x2331b22d | #2331b22d | telegram_api.tl:233 |
| photo | 0xfb197a65 | #fb197a65 | telegram_api.tl:234 |
| photoSizeEmpty | 0xe17e23c | #e17e23c | telegram_api.tl:236 |
| photoSize | 0x75c78e60 | #75c78e60 | telegram_api.tl:237 |
| photoCachedSize | 0x21e1ad6 | #21e1ad6 | telegram_api.tl:238 |
| photoStrippedSize | 0xe0b0bc2e | #e0b0bc2e | telegram_api.tl:239 |
| photoSizeProgressive | 0xfa3efb95 | #fa3efb95 | telegram_api.tl:240 |
| photoPathSize | 0xd8214d41 | #d8214d41 | telegram_api.tl:241 |
| peerUser | 0x59511722 | #59511722 | telegram_api.tl:98 |
| peerChat | 0x36c6019a | #36c6019a | telegram_api.tl:99 |
| peerChannel | 0xa2a5371e | #a2a5371e | telegram_api.tl:100 |
| peerNotifySettings | 0x99622c0c | #99622c0c | telegram_api.tl:263 |
| chatFull | 0x2633421b | #2633421b | telegram_api.tl:132 |
| userFull | 0xe24898fc | #e24898fc | telegram_api.tl:~500 |

---

## 9. Performance Benchmarks

**benches/tl_deserialize.rs:**
```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};

fn bench_deserialize_photo(c: &mut Criterion) {
    let data = include_bytes!("../tests/golden/photo.bin");
    
    c.bench_function("deserialize_photo", |b| {
        b.iter(|| {
            let mut buf = Bytes::new(black_box(data.to_vec()));
            black_box(Photo::deserialize_tl(&mut buf).unwrap())
        })
    });
}

fn bench_deserialize_chat_full(c: &mut Criterion) {
    let data = include_bytes!("../tests/golden/chat_full.bin");
    
    c.bench_function("deserialize_chat_full", |b| {
        b.iter(|| {
            let mut buf = Bytes::new(black_box(data.to_vec()));
            black_box(ChatFull::deserialize_tl(&mut buf).unwrap())
        })
    });
}

criterion_group!(benches, bench_deserialize_photo, bench_deserialize_chat_full);
criterion_main!(benches);
```

---

## 10. Documentation

**README.md:**
```markdown
# rustgram-tl-core

Core TL (Type Language) binary deserialization for Telegram MTProto.

## Overview

This crate provides manual implementations of TL binary format
deserialization for core Telegram types.

## Usage

```rust
use rustgram_tl_core::{Photo, PeerNotifySettings};
use rustgram_types::Bytes;

// Deserialize a Photo from network response
let mut buf = Bytes::new(response_bytes);
let photo = Photo::deserialize_tl(&mut buf)?;

// Access photo data
match photo {
    Photo::Empty { id } => println!("Empty photo: {}", id),
    Photo::Photo { sizes, .. } => {
        for size in sizes {
            println!("Photo size: {}x{}", size.w, size.h);
        }
    }
}
```

## Types

- `Photo` - User and chat photos
- `Peer` - Peer identifiers
- `PeerNotifySettings` - Notification preferences
- `ChatFull` - Full chat information
- `UserFull` - Full user information

## Testing

```bash
# Unit tests
cargo test

# Golden tests (requires TDLib-captured data)
cargo test --test golden_tests

# Benchmarks
cargo bench

# Coverage
cargo llvm-cov --html
```

## License

MIT OR Apache-2.0
```

---

**Version:** 1.0  
**Status:** Draft  
**Owner:** Analyst Agent  
**Review Date:** 2026-01-21
