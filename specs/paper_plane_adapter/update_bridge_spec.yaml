# Update Channel Bridge Specification
# Version: 1.0.0
# Date: 2026-01-21
# Epic: rustgram-client-zwh.2
# Component: paper_plane_adapter crate

metadata:
  module: "update_bridge"
  crate_name: "rustgram-paper-plane-adapter"
  complexity: "medium"
  type: "adapter_bridge"
  estimated_effort: "12-16 hours"
  test_target: ">= 25 tests"
  tdlib_reference:
    file: "references/paper-plane/src/model/client.rs"
    lines: "34, 252-301"
  paper_plane_reference:
    file: "references/paper-plane/src/utils.rs"
    lines: "187-196"

# Module Overview
module_overview: |
  The UpdateBridge module provides a thread-safe bridge between:
  1. ClientActor's tokio::sync::mpsc update channel (tokio runtime)
  2. GTK/glib application thread (glib::MainContext)
  
  Key responsibilities:
  - Subscribe to ClientActor::update_sender (mpsc::UnboundedSender<Update>)
  - Convert rustgram Update types to TDLib-compatible JSON format
  - Deliver updates via async_channel for thread-safe glib consumption
  - Buffer updates per client to prevent data loss
  - Support non-blocking receive() for GTK main loop polling

# Data Structures
data_structures:
  - name: "UpdateBridge"
    type: "struct"
    thread_safety: "Send + Sync"
    fields:
      - name: "client_id"
        type: "ClientId"
        description: "Identifier for the client instance"
      
      - name: "update_receiver"
        type: "mpsc::UnboundedReceiver<client_actor::Update>"
        description: "Receiver from ClientActor::subscribe_updates()"
      
      - name: "async_sender"
        type: "async_channel::Sender<String>"
        description: "Thread-safe sender for JSON updates to glib"
      
      - name: "buffer"
        type: "Arc<Mutex<VecDeque<String>>>"
        description: "Buffer for pending updates (polling model)"
      
      - name: "stopped"
        type: "Arc<AtomicBool>"
        description: "Flag to stop the bridge task"

    lifecycle:
      - name: "new"
        signature: "pub fn new(client_id: ClientId, client_actor: &Arc<ClientActor>) -> Result<Self, BridgeError>"
        description: |
          Creates new UpdateBridge by:
          1. Calling client_actor.subscribe_updates() to get mpsc receiver
          2. Creating async_channel for glib delivery
          3. Spawning tokio task to forward updates
          4. Returning Self with all components initialized
      
      - name: "receive"
        signature: "pub fn receive(&self) -> Option<String>"
        description: |
          Non-blocking receive for GTK polling (matches TDLib::td_receive pattern).
          Returns Some(json_update) if available, None otherwise.
          Must be thread-safe (called from glib thread).
      
      - name: "stop"
        signature: "pub fn stop(&self)"
        description: "Stops the bridge task and closes channels"

  - name: "UpdateConverter"
    type: "trait"
    description: "Trait for converting rustgram updates to TDLib JSON format"
    methods:
      - name: "to_tdlib_json"
        signature: "fn to_tdlib_json(&self) -> Result<String, ConversionError>"
        description: "Convert update to TDLib-compatible JSON string"

  - name: "BridgeError"
    type: "enum"
    derives: ["Debug", "Error", "thiserror::Error"]
    variants:
      - name: "ClientActorUnavailable"
        description: "ClientActor not found or stopped"
      
      - name: "ChannelClosed"
        description: "Update channel closed unexpectedly"
      
      - name: "ConversionFailed"
        fields:
          - name: "update_type"
            type: "String"
          - name: "reason"
            type: "String"
        description: "Failed to convert update to JSON"

# Type Mappings
type_mappings:
  source:
    crate: "client_actor"
    type: "Update"
    file: "crates/client_actor/src/lib.rs"
    lines: "97-128"
    definition: |
      pub enum Update {
          NewMessage(serde_json::Value),
          EditMessage(serde_json::Value),
          DeleteMessages(serde_json::Value),
          AuthorizationState(serde_json::Value),
          UserStatus(serde_json::Value),
          NewChat(serde_json::Value),
          Generic(serde_json::Value),
      }
  
  target:
    format: "JSON string"
    schema: "TDLib JSON API"
    example: |
      {
        "@type": "updateNewMessage",
        "message": {
          "@type": "message",
          "id": 123,
          "content": { "@type": "messageText", "text": { "@type": "formattedText", "text": "Hello" } }
        }
      }
  
  conversion_strategy: |
    Since client_actor::Update already contains serde_json::Value, conversion is:
    1. Extract the inner Value
    2. Add @type field if missing (based on Update variant)
    3. Serialize to JSON string
    4. Return as Result<String, ConversionError>

# Thread Safety Strategy
thread_safety:
  model: "Actor + async_channel"
  
  channels:
    - name: "tokio_update_channel"
      type: "mpsc::UnboundedReceiver<client_actor::Update>"
      direction: "tokio -> UpdateBridge task"
      thread: "tokio runtime"
    
    - name: "glib_update_channel"
      type: "async_channel::Sender<String>"
      direction: "UpdateBridge task -> glib main loop"
      thread: "thread-safe (async_channel)"
    
    - name: "buffer"
      type: "Arc<Mutex<VecDeque<String>>>"
      direction: "shared access"
      thread: "tokio task writes, glib thread reads"
  
  synchronization:
    - "Arc<Mutex<>> for shared state (buffer, stopped flag)"
    - "async_channel for cross-thread communication"
    - "AtomicBool for stop flag"
  
  gtk_integration:
    pattern: "glib::MainContext::spawn_local()"
    reference: "references/paper-plane/src/utils.rs:187-196"
    description: |
      glib thread polls UpdateBridge::receive() in spawn_local future:
      ```rust
      glib::MainContext::default().spawn_local(async move {
          while let Some(update_json) = bridge.receive() {
              handle_update(update_json);
                                  }
      });
      ```

# Update Forwarding Task
update_forwarding_task:
  type: "tokio::task::JoinHandle<()>"
  signature: |
    fn spawn_forwarder(
      client_id: ClientId,
      mut rx: mpsc::UnboundedReceiver<Update>,
      tx: async_channel::Sender<String>,
      buffer: Arc<Mutex<VecDeque<String>>>,
      stopped: Arc<AtomicBool>,
    ) -> JoinHandle<()>
  
  loop_logic: |
    loop {
        if stopped.load(Ordering::Relaxed) {
            break;
        }
        
        match rx.recv().await {
            Some(update) => {
                match convert_to_tdlib_json(update) {
                    Ok(json) => {
                        // Try to send to glib via async_channel
                        if let Err(_) = tx.try_send(json.clone()) {
                            // Fallback: store in buffer for polling
                            buffer.lock().push_back(json);
                        }
                    }
                    Err(e) => {
                        tracing::error!("Conversion error: {:?}", e);
                    }
                }
            }
            None => {
                // Channel closed, stop forwarding
                break;
            }
        }
    }

# Public API
public_api:
  methods:
    - name: "create"
      signature: "pub async fn create(client_id: ClientId, client_actor: Arc<ClientActor>) -> Result<Self, BridgeError>"
      description: "Factory method to create and start UpdateBridge"
      returns: "Initialized UpdateBridge with forwarder task running"
    
    - name: "receive"
      signature: "pub fn receive(&self) -> Option<String>"
      description: "Non-blocking receive for GTK polling (TDLib-compatible)"
      thread_safe: true
      returns: "Some(json_string) if update available, None otherwise"
    
    - name: "subscribe_channel"
      signature: "pub fn subscribe_channel(&self) -> async_channel::Receiver<String>"
      description: "Direct async_channel subscription (alternative to polling)"
      returns: "Receiver that can be used in glib::spawn_local"
    
    - name: "stop"
      signature: "pub async fn stop(self)"
      description: "Graceful shutdown: stops task, closes channels"
    
    - name: "is_running"
      signature: "pub fn is_running(&self) -> bool"
      description: "Check if bridge is still running"
      returns: "false if stopped or channel closed"

# Dependencies
dependencies:
  internal:
    - name: "rustgram-client-actor"
      path: "crates/client_actor"
      items:
        - "ClientActor"
        - "Update"
        - "ClientId"
      reason: "Source of updates from Telegram network"
    
    - name: "rustgram-types"
      path: "crates/types"
      items:
        - "update::Update"
      reason: "TL schema update types (for validation)"
  
  external:
    - name: "tokio"
      version: "1.35"
      features: ["sync", "rt-multi-thread"]
      reason: "Async runtime, mpsc channels"
    
    - name: "async-channel"
      version: "2.0"
      reason: "Thread-safe channel for tokio <-> glib bridge"
    
    - name: "serde"
      version: "1.0"
      features: ["derive"]
      reason: "JSON serialization"
    
    - name: "serde_json"
      version: "1.0"
      reason: "JSON (de)serialization"
    
    - name: "thiserror"
      version: "2.0"
      reason: "Error derivation"
    
    - name: "tracing"
      version: "0.1"
      reason: "Structured logging"
    
    - name: "parking_lot"
      version: "0.12"
      reason: "Fast mutexes for buffer"

# Test Requirements
test_requirements:
  minimum_tests: 25
  coverage_target: "80%"
  test_categories:
    - name: "bridge_lifecycle"
      tests:
        - "test_create_success"
        - "test_create_invalid_client_id"
        - "test_stop_bridge"
        - "test_double_stop"
    
    - name: "update_conversion"
      tests:
        - "test_new_message_to_json"
        - "test_edit_message_to_json"
        - "test_delete_messages_to_json"
        - "test_authorization_state_to_json"
        - "test_user_status_to_json"
        - "test_new_chat_to_json"
        - "test_generic_update_to_json"
        - "test_conversion_error_handling"
    
    - name: "update_forwarding"
      tests:
        - "test_update_received_and_sent"
        - "test_update_fallback_to_buffer"
        - "test_buffer_overflow_handling"
        - "test_stop_stops_forwarding"
    
    - name: "thread_safety"
      tests:
        - "test_concurrent_receive"
        - "test_send_from_tokio_receive_from_glib"
        - "test_buffer_mutex_contention"
    
    - name: "tdlib_compatibility"
      tests:
        - "test_receive_non_blocking"
        - "test_receive_returns_none_when_empty"
        - "test_json_format_matches_tdlib"
        - "test_underscore_case_field_names"

# Integration Points
integration_points:
  client_actor:
    method: "subscribe_updates()"
    returns: "mpsc::UnboundedReceiver<Update>"
    location: "crates/client_actor/src/lib.rs:427-450"
  
  gtk_application:
    pattern: "glib::MainContext::default().spawn_local()"
    reference: "references/paper-plane/src/utils.rs:187-196"
    example: |
      // In GTK client initialization
      let bridge = UpdateBridge::create(client_id, client_actor).await?;
      
      glib::MainContext::default().spawn_local(clone!(@weak bridge => async move {
          while bridge.is_running() {
              if let Some(update_json) = bridge.receive() {
                  handle_tdlib_update(&update_json);
              }
              // Small delay to prevent busy-wait
              glib::timeout_future_seconds(0.01).await;
          }
      }));

# Success Criteria
success_criteria:
  compilation:
    - "Crate compiles without errors"
    - "Zero clippy warnings"
  
  functionality:
    - "UpdateBridge::create() succeeds with valid ClientActor"
    - "Updates flow from ClientActor to glib thread"
    - "receive() is non-blocking (matches TDLib::td_receive)"
    - "JSON format matches TDLib schema"
    - "Bridge stops gracefully"
  
  thread_safety:
    - "No data races in concurrent receive() calls"
    - "Buffer access is thread-safe"
    - "Stop flag is atomic"
  
  testing:
    - ">= 25 tests passing"
    - "All update types tested"
    - "Thread safety verified"

# Implementation Notes
implementation_notes:
  buffer_management:
    - "Use VecDeque with capacity limit (default: 1000)"
    - "Drop oldest updates when full"
    - "Log warnings when dropping"
  
  error_handling:
    - "Conversion errors log and skip (don't crash)"
    - "Channel errors log and stop bridge"
    - "Use Result<T, BridgeError> throughout"
  
  performance:
    - "Use try_send() for async_channel (non-blocking)"
    - "Batch buffer reads if possible"
    - "Avoid JSON re-serialization if already in Value"
  
  tdlib_compatibility:
    - "Use underscore_case for field names"
    - "Include @type field in all JSON objects"
    - "Follow TDLib update naming: updateNewMessage, updateUserStatus, etc."

# TL Constructor IDs
tl_constructors:
  update_new_message: 0x13abd453
  update_edit_message: 0x1f2b0afd
  update_delete_messages: 0xe6f69a1c
  update_authorization_state: 0x7f0159
  update_user_status: 0xec42fb8
  update_new_chat: 0x9a82263
