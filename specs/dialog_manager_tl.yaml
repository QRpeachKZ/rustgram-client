# TL Serialization Specification: DialogManager Network Integration
# Task ID: rustgram-client-ff7.3
# Epic: rustgram-client-ff7 (Phase 0: Network Layer Integration)
# Version: 1.0
# Date: 2026-01-20

# This specification defines the exact TL (Type Language) serialization format
# for all dialog-related network operations in DialogManager.
#
# Based on TDLib TL schema: references/td/td/generate/scheme/telegram_api.tl
# Lines 2337-2357

# ==============================================================================
# SECTION 1: REQUEST TYPES
# ==============================================================================

# ----------------------------------------
# 1.1 GetDialogsRequest
# ----------------------------------------
# TL Schema: messages.getDialogs#a0f4cb4f
# Purpose: Load dialogs from server with pagination

request_types:
  GetDialogsRequest:
    constructor_id: 0xa0f4cb4f  # Verified from telegram_api.tl:2337
    
    # Field definitions
    fields:
      exclude_pinned:
        type: bool
        flag_bit: 0
        description: "Exclude pinned dialogs from results"
        optional: true
        
      folder_id:
        type: i32
        flag_bit: 1
        description: "Folder ID for filtering"
        optional: true
        
      offset_date:
        type: i32
        description: "Timestamp of last dialog in previous page"
        default: 0
        
      offset_id:
        type: i32
        description: "Message ID of last dialog in previous page"
        default: 0
        
      offset_peer:
        type: InputPeer
        description: "Peer of last dialog in previous page"
        default: "InputPeer::empty()"
        
      limit:
        type: i32
        description: "Maximum dialogs to return (1-100)"
        validation:
          min: 1
          max: 100
          
      hash:
        type: i64
        description: "Hash for caching (0 = force reload)"
        default: 0
    
    # Serialization order (must match TDLib exactly)
    serialization_order:
      - flags (u32)
      - folder_id (if flag.1 is set)
      - offset_date (i32)
      - offset_id (i32)
      - offset_peer (InputPeer)
      - limit (i32)
      - hash (i64)
    
    # Byte format specification
    byte_format:
      - step: 1
        field: constructor_id
        type: u32_le
        size: 4
        value: "0xa0f4cb4f"
        
      - step: 2
        field: flags
        type: u32_le
        size: 4
        notes: "Bit 0 = exclude_pinned, Bit 1 = folder_id set"
        
      - step: 3
        field: folder_id
        type: i32_le
        size: 4
        condition: "if flags & 0x2 != 0"
        
      - step: 4
        field: offset_date
        type: i32_le
        size: 4
        
      - step: 5
        field: offset_id
        type: i32_le
        size: 4
        
      - step: 6
        field: offset_peer
        type: InputPeer
        notes: "Serialize InputPeer according to its TL spec"
        
      - step: 7
        field: limit
        type: i32_le
        size: 4
        
      - step: 8
        field: hash
        type: i64_le
        size: 8
    
    # Total size (variable due to InputPeer)
    min_size: 36  # bytes (excluding InputPeer)
    max_size: 72  # bytes (with full InputPeer)

# ----------------------------------------
# 1.2 CreateChatRequest
# ----------------------------------------
# TL Schema: messages.createChat#92ceddd4
# Purpose: Create a new group chat

request_types:
  CreateChatRequest:
    constructor_id: 0x92ceddd4  # Verified from telegram_api.tl:2357
    
    fields:
      users:
        type: Vector<InputUser>
        description: "Users to add to the chat"
        validation:
          min_length: 1
          
      title:
        type: String
        description: "Chat title"
        validation:
          min_length: 1
          max_length: 128
          
      ttl_period:
        type: i32
        flag_bit: 0
        description: "Auto-delete TTL for messages"
        optional: true
        default: null
    
    serialization_order:
      - flags (u32)
      - users (Vector<InputUser>)
      - title (String)
      - ttl_period (i32, if flag.0 is set)
    
    byte_format:
      - step: 1
        field: constructor_id
        type: u32_le
        size: 4
        value: "0x92ceddd4"
        
      - step: 2
        field: flags
        type: u32_le
        size: 4
        notes: "Bit 0 = ttl_period set"
        
      - step: 3
        field: users_count
        type: u32_le
        size: 4
        notes: "Vector length prefix"
        
      - step: 4
        field: users
        type: Vector<InputUser>
        notes: "Repeat for each user: InputUser serialization"
        
      - step: 5
        field: title
        type: String
        notes: "String with length prefix and padding"
        
      - step: 6
        field: ttl_period
        type: i32_le
        size: 4
        condition: "if flags & 0x1 != 0"
    
    min_size: 12  # constructor + flags + vector count
    max_size: 600+  # depends on users and title length

# ----------------------------------------
# 1.3 UpdateTitleRequest
# ----------------------------------------
# TL Schema: messages.editChatTitle#73783ffd
# Purpose: Update chat title

request_types:
  UpdateTitleRequest:
    constructor_id: 0x73783ffd  # Verified from telegram_api.tl:2353
    
    fields:
      chat_id:
        type: i64
        description: "Chat ID to update"
        
      title:
        type: String
        description: "New title"
        validation:
          min_length: 1
          max_length: 128
    
    serialization_order:
      - chat_id (i64)
      - title (String)
    
    byte_format:
      - step: 1
        field: constructor_id
        type: u32_le
        size: 4
        value: "0x73783ffd"
        
      - step: 2
        field: chat_id
        type: i64_le
        size: 8
        
      - step: 3
        field: title
        type: String
        notes: "String with length prefix and padding to 4-byte boundary"
    
    min_size: 12
    max_size: 148  # 12 + max title (128) + padding

# ----------------------------------------
# 1.4 UpdatePhotoRequest
# ----------------------------------------
# TL Schema: messages.editChatPhoto#35ddd674
# Purpose: Update chat photo

request_types:
  UpdatePhotoRequest:
    constructor_id: 0x35ddd674  # Verified from telegram_api.tl:2354
    
    fields:
      chat_id:
        type: i64
        description: "Chat ID to update"
        
      photo:
        type: InputChatPhoto
        description: "New photo (or InputChatPhotoEmpty to remove)"
    
    serialization_order:
      - chat_id (i64)
      - photo (InputChatPhoto)
    
    byte_format:
      - step: 1
        field: constructor_id
        type: u32_le
        size: 4
        value: "0x35ddd674"
        
      - step: 2
        field: chat_id
        type: i64_le
        size: 8
        
      - step: 3
        field: photo
        type: InputChatPhoto
        notes: "Serialize InputChatPhoto according to its TL spec"
    
    min_size: 12
    max_size: 2000+  # depends on photo size

# ==============================================================================
# SECTION 2: RESPONSE TYPES
# ==============================================================================

# ----------------------------------------
# 2.1 GetDialogsResponse
# ----------------------------------------
# Response to GetDialogsRequest
# Can be either messages.Dialogs or messages.DialogsSlice

response_types:
  GetDialogsResponse:
    # Two possible constructors (polymorphic)
    constructors:
      Dialogs:
        id: 0x3646d098  # messages.dialogs
        has_total_count: false
        description: "Full dialogs response (no pagination)"
        
      DialogsSlice:
        id: 0x1834175b  # messages.dialogsSlice
        has_total_count: true
        description: "Paginated dialogs response"
    
    fields:
      dialogs:
        type: Vector<Dialog>
        description: "List of dialogs"
        
      messages:
        type: Vector<Message>
        description: "Top messages for each dialog"
        
      chats:
        type: Vector<Chat>
        description: "Chat objects"
        
      users:
        type: Vector<User>
        description: "User objects"
        
      total_count:
        type: i32
        description: "Total dialog count (only in DialogsSlice)"
        optional: true
    
    # Deserialization order
    deserialization_order:
      - constructor_id (u32) - determines variant
      - dialogs (Vector<Dialog>)
      - messages (Vector<Message>)
      - chats (Vector<Chat>)
      - users (Vector<User>)
      - total_count (i32) - only if constructor == 0x1834175b
    
    byte_format:
      - step: 1
        field: constructor_id
        type: u32_le
        size: 4
        notes: "0x3646d098 for Dialogs, 0x1834175b for DialogsSlice"
        
      - step: 2
        field: dialogs_count
        type: u32_le
        size: 4
        
      - step: 3
        field: dialogs
        type: Vector<Dialog>
        notes: "Deserialize each Dialog struct"
        
      - step: 4
        field: messages_count
        type: u32_le
        size: 4
        
      - step: 5
        field: messages
        type: Vector<Message>
        notes: "Deserialize each Message struct"
        
      - step: 6
        field: chats_count
        type: u32_le
        size: 4
        
      - step: 7
        field: chats
        type: Vector<Chat>
        notes: "Deserialize each Chat struct"
        
      - step: 8
        field: users_count
        type: u32_le
        size: 4
        
      - step: 9
        field: users
        type: Vector<User>
        notes: "Deserialize each User struct"
        
      - step: 10
        field: total_count
        type: i32_le
        size: 4
        condition: "only if constructor_id == 0x1834175b"

# ----------------------------------------
# 2.2 CreateChatResponse
# ----------------------------------------
# Response to CreateChatRequest
# Returns messages.InvitedUsers

response_types:
  CreateChatResponse:
    constructor_id: 0x8bdac491  # messages.invitedUsers (simplified)
    
    fields:
      chat_id:
        type: i64
        description: "Created chat ID"
        
      user_ids:
        type: Vector<i64>
        description: "User IDs in the chat"
    
    deserialization_order:
      - constructor_id (u32)
      - chat_id (i64)
      - user_ids_count (u32)
      - user_ids (Vector<i64>)

# ----------------------------------------
# 2.3 UpdateResponse
# ----------------------------------------
# Response to UpdateTitleRequest and UpdatePhotoRequest
# Returns Updates type

response_types:
  Updates:
    # Multiple possible constructors (polymorphic)
    # For simplicity, we only handle the common case
    
    constructor_id: 0x1a23b8c8  # Updates (simplified)
    
    fields:
      updates:
        type: Vector<Update>
        description: "List of updates"
        
      users:
        type: Vector<User>
        description: "User objects referenced in updates"
        
      chats:
        type: Vector<Chat>
        description: "Chat objects referenced in updates"
    
    deserialization_order:
      - constructor_id (u32)
      - updates_count (u32)
      - updates (Vector<Update>)
      - users_count (u32)
      - users (Vector<User>)
      - chats_count (u32)
      - chats (Vector<Chat>)

# ==============================================================================
# SECTION 3: AUXILIARY TYPES
# ==============================================================================

# These types are used within requests/responses above

auxiliary_types:
  Dialog:
    constructor_id: 0x1ad4ad58  # dialog (from TL schema)
    
    fields:
      peer:
        type: Peer
        description: "Dialog peer"
        
      top_message:
        type: i32
        description: "Top message ID"
        
      read_inbox_max_id:
        type: i32
        description: "Highest read message ID (inbox)"
        
      read_outbox_max_id:
        type: i32
        description: "Highest read message ID (outbox)"
        
      unread_count:
        type: i32
        description: "Unread message count"
        
      notify_settings:
        type: PeerNotifySettings
        description: "Notification settings"
        optional: true
        
      pts:
        type: i32
        description: "PTS for dialog"
        optional: true
        
      draft:
        type: DraftMessage
        description: "Draft message"
        optional: true
    
    serialization_order:
      - flags (u32)
      - peer (Peer)
      - top_message (i32)
      - read_inbox_max_id (i32)
      - read_outbox_max_id (i32)
      - unread_count (i32)
      - notify_settings (PeerNotifySettings, if flag.0)
      - pts (i32, if flag.1)
      - draft (DraftMessage, if flag.2)
  
  Peer:
    # Polymorphic type
    
    constructors:
      PeerUser:
        id: 0x9db4bc8d
        field: user_id (i64)
        
      PeerChat:
        id: 0xbad0e5bb
        field: chat_id (i64)
        
      PeerChannel:
        id: 0xbddde532
        field: channel_id (i64)
        
      Empty:
        id: 0x7f3b18ea
        fields: []
  
  InputPeer:
    # Polymorphic type
    
    constructors:
      InputPeerUser:
        id: 0xdde8a54c
        fields:
          user_id: i64
          access_hash: i64
          
      InputPeerChat:
        id: 0x35a95cb9
        fields:
          chat_id: i64
          
      InputPeerChannel:
        id: 0x27bcbbfc
        fields:
          channel_id: i64
          access_hash: i64
          
      InputPeerEmpty:
        id: 0x7f3b18ea
        fields: []
  
  Message:
    constructor_id: 0x1cb5c415  # message (simplified)
    
    fields:
      id: i32
      from_id: Peer (optional)
      peer: Peer
      date: i32
      message: String
      # ... many more fields in real implementation
  
  Chat:
    constructor_id: 0x91c8611f  # chat (simplified)
    
    fields:
      id: i64
      title: String
      photo: ChatPhoto (optional)
      participants_count: i32 (optional)
      date: i32 (optional)
      # ... many more fields
  
  User:
    constructor_id: 0x8e47110f  # user (simplified)
    
    fields:
      id: i64
      first_name: String (optional)
      last_name: String (optional)
      username: String (optional)
      phone: String (optional)
      # ... many more fields

# ==============================================================================
# SECTION 4: SERIALIZATION RULES
# ==============================================================================

serialization_rules:
  # 4.1 Primitive Types
  primitives:
    i32:
      size: 4
      encoding: little_endian
      padding: none
      
    i64:
      size: 8
      encoding: little_endian
      padding: none
      
    u32:
      size: 4
      encoding: little_endian
      padding: none
      
    bool:
      size: 0
      encoding: flags_bit
      notes: "Encoded as bit in flags field"
  
  # 4.2 String Serialization
  string:
    format: "length-prefixed with padding"
    algorithm:
      - if length < 254:
          - write 1 byte: length
          - pad with (4 - (length + 1) % 4) zeros
          - write string bytes
      - if length >= 254:
          - write 1 byte: 254
          - write 3 bytes: length (little-endian)
          - pad with (4 - length % 4) zeros
          - write string bytes
  
  # 4.3 Vector Serialization
  vector:
    format: "count-prefixed"
    algorithm:
      - write 4 bytes: element count (u32, little-endian)
      - for each element:
          - serialize element according to its type
          - align to 4-byte boundary if needed
  
  # 4.4 Flags Serialization
  flags:
    format: "bitmask"
    algorithm:
      - write 4 bytes: flags value (u32, little-endian)
      - each optional field has a bit position
      - if bit is set, serialize the field
      - if bit is clear, skip the field
  
  # 4.5 Polymorphic Types
  polymorphic:
    format: "constructor-prefixed"
    algorithm:
      - write 4 bytes: constructor ID (u32, little-endian)
      - read constructor ID to determine actual type
      - serialize/deserialize remaining fields based on type

# ==============================================================================
# SECTION 5: PADDING RULES
# ==============================================================================

padding_rules:
  # All TL types are aligned to 4-byte boundaries
  alignment: 4
  
  # String padding
  string_padding:
    rule: "Pad to 4-byte boundary after string data"
    example: "5-byte string → 1 (length) + 5 (data) + 2 (padding) = 8 bytes"
  
  # Vector padding
  vector_padding:
    rule: "No padding between vector elements (each element self-aligned)"
    example: "Vector<i32> → count(4) + element1(4) + element2(4) + ..."
  
  # Struct padding
  struct_padding:
    rule: "Fields are serialized consecutively without padding"
    notes: "Only strings and bytes within structs need padding"

# ==============================================================================
# SECTION 6: EXAMPLE SERIALIZATIONS
# ==============================================================================

examples:
  # Example 1: GetDialogsRequest with default values
  GetDialogsRequest_default:
    request:
      exclude_pinned: false
      folder_id: null
      offset_date: 0
      offset_id: 0
      offset_peer: InputPeer::empty()
      limit: 20
      hash: 0
    
    serialized_hex: |
      a0f4cb4f      # constructor_id
      00000000      # flags (none set)
      00000000      # offset_date
      00000000      # offset_id
      7f3b18ea      # InputPeerEmpty constructor
      00000014      # limit (20)
      0000000000000000  # hash (0)
    
    total_size: 32 bytes
  
  # Example 2: CreateChatRequest
  CreateChatRequest_example:
    request:
      users: [InputUser::user(123456789)]
      title: "Test Group"
      ttl_period: null
    
    serialized_hex: |
      92ceddd4      # constructor_id
      00000000      # flags (none set)
      00000001      # users count (1)
      dde8a54c      # InputPeerUser constructor
      75bc9d4507000000  # user_id (123456789)
      0000000000000000  # access_hash (0)
      0b           # title length (11)
      546573742047726f7570  # "Test Group"
      000000       # padding to 4-byte boundary
    
    total_size: 43 bytes

# ==============================================================================
# SECTION 7: VALIDATION RULES
# ==============================================================================

validation_rules:
  # 7.1 Request Validation
  request_validation:
    GetDialogsRequest:
      - limit >= 1
      - limit <= 100
      - offset_date >= 0
      - offset_id >= 0
      
    CreateChatRequest:
      - users.len() >= 1
      - title.len() >= 1
      - title.len() <= 128
      - ttl_period >= 0 (if set)
      
    UpdateTitleRequest:
      - title.len() >= 1
      - title.len() <= 128
      - chat_id > 0
      
    UpdatePhotoRequest:
      - chat_id > 0
  
  # 7.2 Response Validation
  response_validation:
    GetDialogsResponse:
      - dialogs.len() <= limit (from request)
      - messages.len() == dialogs.len() (or 0 if unavailable)
      - total_count >= dialogs.len() (if present)
      
    CreateChatResponse:
      - chat_id > 0
      - user_ids.len() >= 1
      
    Updates:
      - updates.len() >= 1
      - chats and users may be empty if not needed

# ==============================================================================
# SECTION 8: ERROR CODES
# ==============================================================================

error_codes:
  # Error codes returned by Telegram
  errors:
    400:
      name: "BAD_REQUEST"
      variants:
        CHAT_TITLE_EMPTY: "Title is empty"
        CHAT_TITLE_TOO_LONG: "Title exceeds 128 characters"
        CHAT_NOT_MODIFIED: "No changes detected"
        PEER_ID_INVALID: "Invalid peer ID"
        USER_ID_INVALID: "Invalid user ID"
        
    401:
      name: "UNAUTHORIZED"
      variants:
        SESSION_PASSWORD_NEEDED: "Two-factor authentication required"
        
    420:
      name: "FLOOD_WAIT"
      description: "Rate limited, wait before retry"
      field: "retry_after"
      
    429:
      name: "TOO_MANY_REQUESTS"
      description: "Rate limited"
      field: "retry_after"
      
    500:
      name: "INTERNAL_SERVER_ERROR"
      description: "Server error, retry later"
      
    503:
      name: "SERVICE_UNAVAILABLE"
      description: "Temporarily unavailable"

# ==============================================================================
# SECTION 9: TESTING REQUIREMENTS
# ==============================================================================

testing_requirements:
  # 9.1 Serialization Tests
  serialization_tests:
    - name: "GetDialogsRequest_default_serializes_correctly"
      input: "Default GetDialogsRequest"
      expected_output: "Exact hex match with example"
      
    - name: "CreateChatRequest_with_ttl_serializes_correctly"
      input: "CreateChatRequest with ttl_period set"
      check: "Flag bit 0 is set, ttl_period is serialized"
      
    - name: "UpdateTitleRequest_long_title_padded_correctly"
      input: "128-character title"
      check: "String padding to 4-byte boundary"
  
  # 9.2 Deserialization Tests
  deserialization_tests:
    - name: "GetDialogsResponse_Dialogs_variant_deserializes"
      input: "Response with constructor 0x3646d098"
      check: "No total_count field"
      
    - name: "GetDialogsResponse_DialogsSlice_variant_deserializes"
      input: "Response with constructor 0x1834175b"
      check: "total_count field is present"
      
    - name: "Empty_vector_deserializes_correctly"
      input: "Vector with count 0"
      check: "Empty vector, no elements read"
  
  # 9.3 Roundtrip Tests
  roundtrip_tests:
    - name: "GetDialogsRequest_roundtrip"
      test: "Serialize → Deserialize → Verify equality"
      
    - name: "CreateChatRequest_roundtrip"
      test: "Serialize → Deserialize → Verify equality"
      
    - name: "UpdateTitleRequest_roundtrip"
      test: "Serialize → Deserialize → Verify equality"
      
    - name: "UpdatePhotoRequest_roundtrip"
      test: "Serialize → Deserialize → Verify equality"
  
  # 9.4 Error Tests
  error_tests:
    - name: "Invalid_limit_rejected"
      input: "GetDialogsRequest with limit = 0"
      expected: "ValidationError"
      
    - name: "Empty_title_rejected"
      input: "UpdateTitleRequest with title = ''"
      expected: "ValidationError"
      
    - name: "Unknown_constructor_rejected"
      input: "Response with invalid constructor ID"
      expected: "DeserializationError"

# ==============================================================================
# SECTION 10: IMPLEMENTATION NOTES
# ==============================================================================

implementation_notes:
  # 10.1 Use Existing TL Infrastructure
  infrastructure:
    note: "Use TlSerialize and TlDeserialize traits from crates/types/src/tl.rs"
    traits:
      - TlSerialize::serialize_tl(&self, buf: &mut BytesMut)
      - TlDeserialize::deserialize_tl(buf: &mut Bytes) -> Result<Self>
    helpers:
      - TlHelper::write_i32, write_i64, write_bytes, write_string
      - TlHelper::read_i32, read_i64, read_bytes, read_string
  
  # 10.2 Constructor ID Constants
  constructor_ids:
    location: "Define as const u32 in each struct"
    example: "pub const CONSTRUCTOR_ID: u32 = 0xa0f4cb4f;"
    
  # 10.3 Error Handling
  error_handling:
    use_result_types: "TypeResult<T> from crates/types/src/error.rs"
    map_errors: "Convert TypeError to DialogError where needed"
    
  # 10.4 Testing Strategy
  testing:
    unit_tests: "Test each serialization/deserialization separately"
    integration_tests: "Test full request → response cycle"
    property_tests: "Use proptest for roundtrip verification"

# ==============================================================================
# END OF SPECIFICATION
# ==============================================================================

version_history:
  - version: "1.0"
    date: "2026-01-20"
    author: "Analyst Agent"
    changes: "Initial specification based on telegram_api.tl:2337-2357"
