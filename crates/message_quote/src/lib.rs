// Copyright 2024 rustgram-client contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! # Message Quote
//!
//! Represents a quote within a message reply or forward.
//!
//! This module provides the `MessageQuote` struct, which represents quoted text
//! within Telegram messages. It aligns with TDLib's `MessageQuote` class from
//! `td/telegram/MessageQuote.h`.
//!
//! ## Overview
//!
//! Message quotes contain formatted text that is being quoted from another message,
//! along with the position of the quote within the original message and whether
//! the quote was manually selected or automatically generated.
//!
//! ## Usage
//!
//! ```rust
//! use rustgram_message_quote::MessageQuote;
//! use rustgram_formatted_text::FormattedText;
//!
//! // Create a manual quote
//! let text = FormattedText::new("Hello, world!");
//! let quote = MessageQuote::manual(text.clone(), 0).unwrap();
//! assert!(!quote.is_empty());
//! assert!(quote.is_manual());
//!
//! // Create an automatic quote
//! let auto_quote = MessageQuote::automatic(text).unwrap();
//! assert!(!auto_quote.is_manual());
//! ```
//!
//! ## TDLib Alignment
//!
//! This struct matches TDLib's `MessageQuote` class:
//! - TDLib: `text_` (FormattedText) ‚Üí Rust: `text`
//! - TDLib: `position_` (int32) ‚Üí Rust: `position`
//! - TDLib: `is_manual_` (bool) ‚Üí Rust: `is_manual`
//!
//! ## Thread Safety
//!
//! `MessageQuote` is `Clone` and `Send + `Sync`, making it safe to use across threads.

use rustgram_formatted_text::FormattedText;
use serde::{Deserialize, Serialize};
use std::fmt;

/// Errors that can occur when working with message quotes.
#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]
pub enum MessageQuoteError {
    /// Invalid position for the quote.
    #[error("Invalid quote position: {position}")]
    InvalidPosition { position: i32 },

    /// Cannot create a quote with empty text.
    #[error("Cannot create quote with empty text")]
    EmptyText,
}

/// Message quote information.
///
/// Represents a quote within a message reply or forward. Contains the quoted
/// text, its position in the original message, and whether it was manually
/// selected by the user or automatically generated.
///
/// # Examples
///
/// ```
/// use rustgram_message_quote::MessageQuote;
/// use rustgram_formatted_text::FormattedText;
///
/// let text = FormattedText::new("Hello, world!");
/// let quote = MessageQuote::manual(text.clone(), 0).unwrap();
/// assert_eq!(quote.text(), &text);
/// assert_eq!(quote.position(), 0);
/// assert!(quote.is_manual());
/// ```
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct MessageQuote {
    /// The quoted text with formatting entities.
    text: FormattedText,

    /// Position of the quote in the original message (in UTF-16 code units).
    position: i32,

    /// Whether the quote was manually selected by the user.
    ///
    /// `false` means the quote was automatically generated.
    is_manual: bool,
}

impl MessageQuote {
    /// Creates a new manual quote.
    ///
    /// # Arguments
    ///
    /// * `text` - The quoted text with formatting
    /// * `position` - Position of the quote in the original message
    ///
    /// # Returns
    ///
    /// Returns `Err(MessageQuoteError::EmptyText)` if the text is empty.
    ///
    /// # Examples
    ///
    /// ```
    /// use rustgram_message_quote::MessageQuote;
    /// use rustgram_formatted_text::FormattedText;
    ///
    /// let text = FormattedText::new("Quote text");
    /// let quote = MessageQuote::manual(text, 0);
    /// assert!(quote.is_ok());
    /// ```
    pub fn manual(text: FormattedText, position: i32) -> Result<Self, MessageQuoteError> {
        if text.is_empty() {
            return Err(MessageQuoteError::EmptyText);
        }

        Ok(Self {
            text,
            position: position.max(0),
            is_manual: true,
        })
    }

    /// Creates a new automatic quote.
    ///
    /// Automatic quotes are generated by the system, not manually selected
    /// by the user. The position is always 0 for automatic quotes.
    ///
    /// # Arguments
    ///
    /// * `text` - The quoted text with formatting
    ///
    /// # Returns
    ///
    /// Returns `Err(MessageQuoteError::EmptyText)` if the text is empty.
    ///
    /// # Examples
    ///
    /// ```
    /// use rustgram_message_quote::MessageQuote;
    /// use rustgram_formatted_text::FormattedText;
    ///
    /// let text = FormattedText::new("Auto quote");
    /// let quote = MessageQuote::automatic(text);
    /// assert!(quote.is_ok());
    /// assert!(quote.unwrap().is_automatic());
    /// ```
    pub fn automatic(text: FormattedText) -> Result<Self, MessageQuoteError> {
        if text.is_empty() {
            return Err(MessageQuoteError::EmptyText);
        }

        Ok(Self {
            text,
            position: 0,
            is_manual: false,
        })
    }

    /// Creates a new quote with manual flag.
    ///
    /// # Arguments
    ///
    /// * `text` - The quoted text with formatting
    /// * `position` - Position of the quote in the original message
    /// * `is_manual` - Whether the quote was manually selected
    ///
    /// # Examples
    ///
    /// ```
    /// use rustgram_message_quote::MessageQuote;
    /// use rustgram_formatted_text::FormattedText;
    ///
    /// let text = FormattedText::new("Quote");
    /// let quote = MessageQuote::new(text, 10, true);
    /// assert_eq!(quote.position(), 10);
    /// ```
    pub fn new(text: FormattedText, position: i32, is_manual: bool) -> Self {
        Self {
            text,
            position: position.max(0),
            is_manual,
        }
    }

    /// Returns the quoted text.
    ///
    /// # Examples
    ///
    /// ```
    /// use rustgram_message_quote::MessageQuote;
    /// use rustgram_formatted_text::FormattedText;
    ///
    /// let text = FormattedText::new("Hello");
    /// let quote = MessageQuote::new(text.clone(), 0, true);
    /// assert_eq!(quote.text(), &text);
    /// ```
    #[must_use]
    pub const fn text(&self) -> &FormattedText {
        &self.text
    }

    /// Returns the position of the quote in the original message.
    ///
    /// The position is in UTF-16 code units.
    ///
    /// # Examples
    ///
    /// ```
    /// use rustgram_message_quote::MessageQuote;
    /// use rustgram_formatted_text::FormattedText;
    ///
    /// let text = FormattedText::new("Quote");
    /// let quote = MessageQuote::new(text, 100, true);
    /// assert_eq!(quote.position(), 100);
    /// ```
    #[must_use]
    pub const fn position(&self) -> i32 {
        self.position
    }

    /// Sets the position of the quote.
    ///
    /// # Examples
    ///
    /// ```
    /// use rustgram_message_quote::MessageQuote;
    /// use rustgram_formatted_text::FormattedText;
    ///
    /// let text = FormattedText::new("Quote");
    /// let mut quote = MessageQuote::new(text, 0, true);
    /// quote.set_position(50);
    /// assert_eq!(quote.position(), 50);
    /// ```
    pub fn set_position(&mut self, position: i32) {
        self.position = position.max(0);
    }

    /// Returns `true` if the quote was manually selected by the user.
    ///
    /// # Examples
    ///
    /// ```
    /// use rustgram_message_quote::MessageQuote;
    /// use rustgram_formatted_text::FormattedText;
    ///
    /// let text = FormattedText::new("Quote");
    /// let quote = MessageQuote::new(text, 0, true);
    /// assert!(quote.is_manual());
    /// ```
    #[must_use]
    pub const fn is_manual(&self) -> bool {
        self.is_manual
    }

    /// Returns `true` if the quote was automatically generated.
    ///
    /// # Examples
    ///
    /// ```
    /// use rustgram_message_quote::MessageQuote;
    /// use rustgram_formatted_text::FormattedText;
    ///
    /// let text = FormattedText::new("Quote");
    /// let quote = MessageQuote::new(text, 0, false);
    /// assert!(quote.is_automatic());
    /// ```
    #[must_use]
    pub const fn is_automatic(&self) -> bool {
        !self.is_manual
    }

    /// Sets whether the quote is manual.
    ///
    /// # Examples
    ///
    /// ```
    /// use rustgram_message_quote::MessageQuote;
    /// use rustgram_formatted_text::FormattedText;
    ///
    /// let text = FormattedText::new("Quote");
    /// let mut quote = MessageQuote::new(text, 0, false);
    /// quote.set_manual(true);
    /// assert!(quote.is_manual());
    /// ```
    pub fn set_manual(&mut self, is_manual: bool) {
        self.is_manual = is_manual;
    }

    /// Returns `true` if the quote is empty (has no text).
    ///
    /// # Examples
    ///
    /// ```
    /// use rustgram_message_quote::MessageQuote;
    /// use rustgram_formatted_text::FormattedText;
    ///
    /// let text = FormattedText::new("Quote");
    /// let quote = MessageQuote::new(text, 0, true);
    /// assert!(!quote.is_empty());
    /// ```
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.text.is_empty()
    }

    /// Returns the length of the quoted text.
    ///
    /// # Examples
    ///
    /// ```
    /// use rustgram_message_quote::MessageQuote;
    /// use rustgram_formatted_text::FormattedText;
    ///
    /// let text = FormattedText::new("Hello");
    /// let quote = MessageQuote::new(text, 0, true);
    /// assert_eq!(quote.len(), 5);
    /// ```
    #[must_use]
    pub fn len(&self) -> usize {
        self.text.len()
    }

    /// Creates a clone of this quote, optionally ignoring the manual flag.
    ///
    /// # Arguments
    ///
    /// * `ignore_is_manual` - If true, sets the cloned quote to manual
    ///
    /// # Examples
    ///
    /// ```
    /// use rustgram_message_quote::MessageQuote;
    /// use rustgram_formatted_text::FormattedText;
    ///
    /// let text = FormattedText::new("Quote");
    /// let quote = MessageQuote::new(text, 0, false);
    /// let cloned = quote.clone_with_manual_flag(true);
    /// assert!(cloned.is_manual());
    /// ```
    #[must_use]
    pub fn clone_with_manual_flag(&self, ignore_is_manual: bool) -> Self {
        Self {
            text: self.text.clone(),
            position: self.position,
            is_manual: if ignore_is_manual {
                true
            } else {
                self.is_manual
            },
        }
    }

    /// Checks if this quote needs a change warning compared to another quote.
    ///
    /// Returns:
    /// - `Some(1)` if the quote changed in a way that requires a warning
    /// - `Some(-1)` if the automatic quote changed (may happen if original was edited)
    /// - `Some(0)` if no warning needed
    ///
    /// # Examples
    ///
    /// ```
    /// use rustgram_message_quote::MessageQuote;
    /// use rustgram_formatted_text::FormattedText;
    ///
    /// let text1 = FormattedText::new("Quote 1");
    /// let text2 = FormattedText::new("Quote 2");
    /// let quote1 = MessageQuote::new(text1, 0, true);
    /// let quote2 = MessageQuote::new(text2, 0, true);
    /// assert_eq!(quote1.need_change_warning(&quote2), Some(1));
    /// ```
    #[must_use]
    pub fn need_change_warning(&self, other: &Self) -> Option<i32> {
        if self.position != other.position {
            let min_len = self.text.len().min(other.text.len()) as i32;
            if self.position < min_len && other.position < min_len {
                // Quote position can't change
                return Some(1);
            }
        }

        if self.is_manual != other.is_manual {
            // Quote manual property can't change
            return Some(1);
        }

        if self.text != other.text {
            if self.is_manual {
                return Some(1);
            }
            // Automatic quote can change if the original message was edited
            return Some(-1);
        }

        Some(0)
    }

    /// Removes entities that are not allowed in quotes.
    ///
    /// TDLib only allows certain entity types in quotes:
    /// - Bold
    /// - Italic
    /// - Underline
    /// - Strikethrough
    /// - Spoiler
    /// - CustomEmoji
    ///
    /// # Examples
    ///
    /// ```
    /// use rustgram_message_quote::MessageQuote;
    /// use rustgram_formatted_text::{FormattedText, MessageEntity};
    ///
    /// let mut text = FormattedText::new("Quote");
    /// text.add_entity(MessageEntity::new("bold", 0, 5));
    /// text.add_entity(MessageEntity::new("url", 0, 5));
    /// let mut quote = MessageQuote::new(text, 0, true);
    /// quote.remove_disallowed_entities();
    /// // URL entity should be removed
    /// ```
    pub fn remove_disallowed_entities(&mut self) {
        let entities: Vec<_> = self.text.entities().to_vec();
        let filtered: Vec<_> = entities
            .into_iter()
            .filter(|entity| {
                matches!(
                    entity.entity_type(),
                    "bold" | "italic" | "underline" | "strikethrough" | "spoiler" | "customEmoji"
                )
            })
            .collect();

        // Create a new formatted text with only the allowed entities
        self.text = FormattedText::with_entities(self.text.text(), filtered);
    }

    /// Truncates the quote text to a maximum length.
    ///
    /// # Arguments
    ///
    /// * `max_length` - Maximum length of the quote text
    ///
    /// # Examples
    ///
    /// ```
    /// use rustgram_message_quote::MessageQuote;
    /// use rustgram_formatted_text::FormattedText;
    ///
    /// let text = FormattedText::new("This is a very long quote");
    /// let mut quote = MessageQuote::new(text, 0, true);
    /// quote.truncate(10);
    /// assert_eq!(quote.text().text(), "This is a ");
    /// ```
    pub fn truncate(&mut self, max_length: usize) {
        if self.text.len() > max_length {
            let truncated = &self.text.text()[..max_length.min(self.text.len())];
            self.text = FormattedText::with_entities(truncated, Vec::new());
        }
    }
}

impl Default for MessageQuote {
    fn default() -> Self {
        Self {
            text: FormattedText::default(),
            position: 0,
            is_manual: true,
        }
    }
}

impl fmt::Display for MessageQuote {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if self.is_empty() {
            return write!(f, "empty quote");
        }

        let manual_str = if self.is_manual { "" } else { " automatically" };
        let position_str = if self.position != 0 {
            format!(" at position {}", self.position)
        } else {
            String::new()
        };

        write!(
            f,
            "{}{} quoted bytes{}",
            self.len(),
            manual_str,
            position_str
        )
    }
}

impl From<FormattedText> for MessageQuote {
    fn from(text: FormattedText) -> Self {
        Self {
            text,
            position: 0,
            is_manual: true,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustgram_formatted_text::MessageEntity;

    // Basic trait tests
    #[test]
    fn test_default() {
        let quote = MessageQuote::default();
        assert!(quote.is_empty());
        assert_eq!(quote.position(), 0);
        assert!(quote.is_manual());
    }

    #[test]
    fn test_clone() {
        let text = FormattedText::new("Quote text");
        let quote1 = MessageQuote::new(text.clone(), 10, true);
        let quote2 = quote1.clone();
        assert_eq!(quote1, quote2);
    }

    #[test]
    fn test_equality() {
        let text = FormattedText::new("Quote text");
        let quote1 = MessageQuote::new(text.clone(), 10, true);
        let quote2 = MessageQuote::new(text.clone(), 10, true);
        assert_eq!(quote1, quote2);

        let quote3 = MessageQuote::new(text, 20, true);
        assert_ne!(quote1, quote3);
    }

    #[test]
    fn test_hash() {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};

        let text = FormattedText::new("Quote text");
        let quote1 = MessageQuote::new(text.clone(), 10, true);
        let quote2 = MessageQuote::new(text.clone(), 10, true);

        let mut hasher1 = DefaultHasher::new();
        let mut hasher2 = DefaultHasher::new();

        quote1.hash(&mut hasher1);
        quote2.hash(&mut hasher2);

        assert_eq!(hasher1.finish(), hasher2.finish());
    }

    // Constructor tests
    #[test]
    fn test_new() {
        let text = FormattedText::new("Quote text");
        let quote = MessageQuote::new(text.clone(), 100, true);
        assert_eq!(quote.text(), &text);
        assert_eq!(quote.position(), 100);
        assert!(quote.is_manual());
    }

    #[test]
    fn test_new_negative_position() {
        let text = FormattedText::new("Quote text");
        let quote = MessageQuote::new(text, -10, true);
        assert_eq!(quote.position(), 0); // Negative position clamped to 0
    }

    #[test]
    fn test_manual() {
        let text = FormattedText::new("Manual quote");
        let quote = MessageQuote::manual(text, 50);
        assert!(quote.is_ok());
        let quote = quote.unwrap();
        assert_eq!(quote.position(), 50);
        assert!(quote.is_manual());
    }

    #[test]
    fn test_manual_empty_text() {
        let text = FormattedText::new("");
        let quote = MessageQuote::manual(text, 0);
        assert!(quote.is_err());
        assert_eq!(quote.unwrap_err(), MessageQuoteError::EmptyText);
    }

    #[test]
    fn test_automatic() {
        let text = FormattedText::new("Auto quote");
        let quote = MessageQuote::automatic(text);
        assert!(quote.is_ok());
        let quote = quote.unwrap();
        assert_eq!(quote.position(), 0);
        assert!(quote.is_automatic());
    }

    #[test]
    fn test_automatic_empty_text() {
        let text = FormattedText::new("");
        let quote = MessageQuote::automatic(text);
        assert!(quote.is_err());
        assert_eq!(quote.unwrap_err(), MessageQuoteError::EmptyText);
    }

    // Getter/setter tests
    #[test]
    fn test_text() {
        let text = FormattedText::new("Quote text");
        let quote = MessageQuote::new(text.clone(), 0, true);
        assert_eq!(quote.text(), &text);
    }

    #[test]
    fn test_position() {
        let text = FormattedText::new("Quote text");
        let quote = MessageQuote::new(text, 123, true);
        assert_eq!(quote.position(), 123);
    }

    #[test]
    fn test_set_position() {
        let text = FormattedText::new("Quote text");
        let mut quote = MessageQuote::new(text, 0, true);
        quote.set_position(200);
        assert_eq!(quote.position(), 200);

        quote.set_position(-50);
        assert_eq!(quote.position(), 0); // Clamped to 0
    }

    #[test]
    fn test_is_manual() {
        let text = FormattedText::new("Quote text");
        let quote = MessageQuote::new(text, 0, true);
        assert!(quote.is_manual());
        assert!(!quote.is_automatic());
    }

    #[test]
    fn test_is_automatic() {
        let text = FormattedText::new("Quote text");
        let quote = MessageQuote::new(text, 0, false);
        assert!(quote.is_automatic());
        assert!(!quote.is_manual());
    }

    #[test]
    fn test_set_manual() {
        let text = FormattedText::new("Quote text");
        let mut quote = MessageQuote::new(text, 0, false);
        assert!(!quote.is_manual());

        quote.set_manual(true);
        assert!(quote.is_manual());

        quote.set_manual(false);
        assert!(!quote.is_manual());
    }

    // Property tests
    #[test]
    fn test_is_empty() {
        let text = FormattedText::new("Quote text");
        let quote = MessageQuote::new(text, 0, true);
        assert!(!quote.is_empty());

        let empty_quote = MessageQuote::default();
        assert!(empty_quote.is_empty());
    }

    #[test]
    fn test_len() {
        let text = FormattedText::new("Hello");
        let quote = MessageQuote::new(text, 0, true);
        assert_eq!(quote.len(), 5);

        let empty_quote = MessageQuote::default();
        assert_eq!(empty_quote.len(), 0);
    }

    // Clone with manual flag tests
    #[test]
    fn test_clone_with_manual_flag_ignore() {
        let text = FormattedText::new("Quote text");
        let quote = MessageQuote::new(text, 0, false);
        assert!(!quote.is_manual());

        let cloned = quote.clone_with_manual_flag(true);
        assert!(cloned.is_manual());
        assert_eq!(cloned.position(), quote.position());
        assert_eq!(cloned.text(), quote.text());
    }

    #[test]
    fn test_clone_with_manual_flag_preserve() {
        let text = FormattedText::new("Quote text");
        let quote = MessageQuote::new(text, 0, false);
        assert!(!quote.is_manual());

        let cloned = quote.clone_with_manual_flag(false);
        assert!(!cloned.is_manual());
    }

    // Need change warning tests
    #[test]
    fn test_need_change_warning_same() {
        let text = FormattedText::new("Quote text");
        let quote1 = MessageQuote::new(text.clone(), 10, true);
        let quote2 = MessageQuote::new(text, 10, true);
        assert_eq!(quote1.need_change_warning(&quote2), Some(0));
    }

    #[test]
    fn test_need_change_warning_position_changed() {
        let text = FormattedText::new("Quote text");
        let quote1 = MessageQuote::new(text.clone(), 5, true);
        let quote2 = MessageQuote::new(text.clone(), 15, true);
        // Position changed but both are within text bounds, no warning per TDLib logic
        assert_eq!(quote1.need_change_warning(&quote2), Some(0));

        // Position changed with one outside bounds, should warn
        let text2 = FormattedText::new("Short");
        let quote3 = MessageQuote::new(text2, 20, true);
        assert_eq!(quote1.need_change_warning(&quote3), Some(1));
    }

    #[test]
    fn test_need_change_warning_manual_changed() {
        let text = FormattedText::new("Quote text");
        let quote1 = MessageQuote::new(text.clone(), 10, true);
        let quote2 = MessageQuote::new(text, 10, false);
        assert_eq!(quote1.need_change_warning(&quote2), Some(1));
    }

    #[test]
    fn test_need_change_warning_text_changed_manual() {
        let text1 = FormattedText::new("Quote 1");
        let text2 = FormattedText::new("Quote 2");
        let quote1 = MessageQuote::new(text1, 10, true);
        let quote2 = MessageQuote::new(text2, 10, true);
        assert_eq!(quote1.need_change_warning(&quote2), Some(1));
    }

    #[test]
    fn test_need_change_warning_text_changed_automatic() {
        let text1 = FormattedText::new("Quote 1");
        let text2 = FormattedText::new("Quote 2");
        let quote1 = MessageQuote::new(text1, 10, false);
        let quote2 = MessageQuote::new(text2, 10, false);
        assert_eq!(quote1.need_change_warning(&quote2), Some(-1));
    }

    // Remove disallowed entities tests
    #[test]
    fn test_remove_disallowed_entities() {
        let mut text = FormattedText::new("Quote text");
        text.add_entity(MessageEntity::new("bold", 0, 5));
        text.add_entity(MessageEntity::new("url", 0, 5));
        text.add_entity(MessageEntity::new("italic", 6, 4));

        let mut quote = MessageQuote::new(text, 0, true);
        quote.remove_disallowed_entities();

        assert_eq!(quote.text().entities().len(), 2); // bold and italic remain
        assert_eq!(quote.text().entities()[0].entity_type(), "bold");
        assert_eq!(quote.text().entities()[1].entity_type(), "italic");
    }

    #[test]
    fn test_remove_disallowed_entities_all_allowed() {
        let allowed_types = [
            ("bold", "bold"),
            ("italic", "italic"),
            ("underline", "underline"),
            ("strikethrough", "strikethrough"),
            ("spoiler", "spoiler"),
            ("customEmoji", "customEmoji"),
        ];

        for (entity_type, expected) in allowed_types {
            let mut text = FormattedText::new("Quote text");
            text.add_entity(MessageEntity::new(entity_type, 0, 5));

            let mut quote = MessageQuote::new(text, 0, true);
            quote.remove_disallowed_entities();

            assert_eq!(quote.text().entities().len(), 1);
            assert_eq!(quote.text().entities()[0].entity_type(), expected);
        }
    }

    #[test]
    fn test_remove_disallowed_entities_none_allowed() {
        let disallowed_types = ["url", "pre", "code", "textLink", "mention"];

        for entity_type in disallowed_types {
            let mut text = FormattedText::new("Quote text");
            text.add_entity(MessageEntity::new(entity_type, 0, 5));

            let mut quote = MessageQuote::new(text, 0, true);
            quote.remove_disallowed_entities();

            assert_eq!(quote.text().entities().len(), 0);
        }
    }

    // Truncate tests
    #[test]
    fn test_truncate() {
        let text = FormattedText::new("This is a very long quote text");
        let mut quote = MessageQuote::new(text, 0, true);
        quote.truncate(10);
        assert_eq!(quote.text().text(), "This is a ");
        assert_eq!(quote.len(), 10);
    }

    #[test]
    fn test_truncate_shorter_than_length() {
        let text = FormattedText::new("Short");
        let mut quote = MessageQuote::new(text, 0, true);
        quote.truncate(100);
        assert_eq!(quote.text().text(), "Short");
        assert_eq!(quote.len(), 5);
    }

    #[test]
    fn test_truncate_zero() {
        let text = FormattedText::new("Quote text");
        let mut quote = MessageQuote::new(text, 0, true);
        quote.truncate(0);
        assert_eq!(quote.text().text(), "");
        assert!(quote.is_empty());
    }

    // Display tests
    #[test]
    fn test_display_empty() {
        let quote = MessageQuote::default();
        assert_eq!(format!("{}", quote), "empty quote");
    }

    #[test]
    fn test_display_manual() {
        let text = FormattedText::new("Quote text");
        let quote = MessageQuote::new(text, 0, true);
        assert_eq!(format!("{}", quote), "10 quoted bytes");
    }

    #[test]
    fn test_display_automatic() {
        let text = FormattedText::new("Quote text");
        let quote = MessageQuote::new(text, 0, false);
        assert_eq!(format!("{}", quote), "10 automatically quoted bytes");
    }

    #[test]
    fn test_display_with_position() {
        let text = FormattedText::new("Quote text");
        let quote = MessageQuote::new(text, 100, true);
        assert_eq!(format!("{}", quote), "10 quoted bytes at position 100");
    }

    // From trait tests
    #[test]
    fn test_from_formatted_text() {
        let text = FormattedText::new("Quote text");
        let quote = MessageQuote::from(text.clone());
        assert_eq!(quote.text(), &text);
        assert_eq!(quote.position(), 0);
        assert!(quote.is_manual());
    }

    // Serialization tests
    #[test]
    fn test_serialization() {
        let text = FormattedText::new("Quote text");
        let quote = MessageQuote::new(text, 50, true);
        let json = serde_json::to_string(&quote).unwrap();
        let parsed: MessageQuote = serde_json::from_str(&json).unwrap();
        assert_eq!(quote, parsed);
    }

    // Edge case tests
    #[test]
    fn test_zero_position() {
        let text = FormattedText::new("Quote text");
        let quote = MessageQuote::new(text, 0, true);
        assert_eq!(quote.position(), 0);
    }

    #[test]
    fn test_large_position() {
        let text = FormattedText::new("Quote text");
        let quote = MessageQuote::new(text, 1000000, true);
        assert_eq!(quote.position(), 1000000);
    }

    #[test]
    fn test_unicode_text() {
        let text = FormattedText::new("Hello üåç");
        let quote = MessageQuote::new(text, 0, true);
        assert!(!quote.is_empty());
        assert_eq!(quote.len(), 10); // 5 + 1 + 4 (emoji is 4 bytes)
    }

    #[test]
    fn test_empty_entities() {
        let text = FormattedText::new("Quote text");
        let quote = MessageQuote::new(text, 0, true);
        assert_eq!(quote.text().entities().len(), 0);
    }

    #[test]
    fn test_with_entities() {
        let mut text = FormattedText::new("Quote text");
        text.add_entity(MessageEntity::new("bold", 0, 5));
        let quote = MessageQuote::new(text, 0, true);
        assert_eq!(quote.text().entities().len(), 1);
    }

    #[test]
    fn test_multiple_entities() {
        let mut text = FormattedText::new("Quote text here");
        text.add_entity(MessageEntity::new("bold", 0, 5));
        text.add_entity(MessageEntity::new("italic", 6, 4));
        text.add_entity(MessageEntity::new("underline", 11, 4));

        let quote = MessageQuote::new(text, 0, true);
        assert_eq!(quote.text().entities().len(), 3);
    }

    #[test]
    fn test_clone_with_different_positions() {
        let text = FormattedText::new("Quote text");
        let quote1 = MessageQuote::new(text.clone(), 0, true);
        let quote2 = MessageQuote::new(text.clone(), 100, true);
        // quote3 has position -50 which gets clamped to 0, so it equals quote1
        let quote3 = MessageQuote::new(text, -50, true);

        assert_ne!(quote1, quote2);
        // Note: quote3 has position clamped to 0, so it equals quote1
        assert_eq!(quote1, quote3);
        assert_ne!(quote2, quote3);
    }

    #[test]
    fn test_position_boundary_values() {
        let text = FormattedText::new("Quote");
        let positions = [0, 1, 100, 1000, i32::MAX];

        for position in positions {
            let quote = MessageQuote::new(text.clone(), position, true);
            assert_eq!(quote.position(), position);
        }
    }

    #[test]
    fn test_negative_positions_clamped() {
        let text = FormattedText::new("Quote");
        let positions = [-1, -10, -100, i32::MIN];

        for position in positions {
            let quote = MessageQuote::new(text.clone(), position, true);
            assert_eq!(quote.position(), 0);
        }
    }
}
